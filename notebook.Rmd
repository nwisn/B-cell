---
title: "Analysis of immune biomarkers after MCS device implantation"
author: "Nicholas Wisniewski"
date: June 28, 2018
output:
  html_document:
    toc: true
    toc_depth: 4
    toc_float: true
    collapsed: true
    number_sections: false
    theme: cosmo
    df_print: kable
    code_folding: hide
---

```{r load_libraries, include=FALSE}
load("data_combined.RData")
df$`Device Type` <- relevel(df$`Device Type`, ref = "HMII")
bc <- 14:42
cyt <- 43:80
bcellcyto <- c(bc,cyt)
groups <- make.names(c("AgeGreater60", 
                       "Sex",
                       "LowIntermacs",
                       "RVAD", 
                       "Sensitized",
                       "VAD Indication", 
                       #"Device Type", 
                       "Survival",
                       "Outcome"))


suppressMessages(require(knitr, quietly = T))
suppressMessages(require(kableExtra, quietly = T))
suppressMessages(require(rmarkdown, quietly = T))
suppressMessages(require(plyr, quietly = T))
suppressMessages(require(dplyr, quietly = T))
suppressMessages(require(parallel, quietly = TRUE))
suppressMessages(require(ggsci, quietly = TRUE))
suppressMessages(require(ggplot2, quietly = T))
suppressMessages(require(GGally, quietly = T))
suppressMessages(require(reshape2, quietly = T))
suppressMessages(require(stringr, quietly = T))
capture.output(invisible(suppressMessages(require(WGCNA, quietly = T))))

# Efron's double standardization
double_standardize <- function(x, niter = 1000) {
    for(i in 1:niter) x <- t(scale(t(scale(x))))
    return(as.data.frame(x))
}
```


# Introduction

`r nlevels(df$PatientID)` heart-failure patients were sampled at `r length(unique(df$Time))` timepoints after MCS device implantation. Patients received one of 5 different MCS devices, though the HeartMate II comprised `r round(140/sum(table(df[["Device Type"]]))*100)` percent of the samples. For this reason, we focused our subsequent analysis on the HeartMate II, but were able to take advantage of the remaining samples to explore some of the variability across devices.

Each sample consisted of `r length(bcellcyto)` biomarker measurements -- `r length(bc)` B-cell markers and `r length(cyt)` cytokine markers. Additionally, each patient was associated with 8 categorical variables, such as age, sex, INTERMACS score, and outcome. 

Due to practical limitations, not all samples are guaranteed to have both B-cell and cytokine marker measurements, and other samples are missing altogether. After accounting for missing data, there are a total of `r nrow(df) - length(Reduce(intersect, apply(df[,bcellcyto], 2, function(x) which(is.na(x)))))` datapoints.


## Raw data


```{r show_raw_data, message=FALSE}
missing.ix <- Reduce(intersect, apply(df[,bcellcyto], 2, function(x) which(is.na(x))))
df.raw <- df[-missing.ix,]
df.raw <- df.raw[order(df.raw$PatientID),]
rownames(df.raw) <- 1:nrow(df.raw)
kable(df.raw, 
      digits = 3,
      row.names = T,
      caption = "Raw Data"
) %>%
    kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                  font_size = 12) %>%
    scroll_box(width = "100%", height = "300px") 


```








# HeartMate-II analysis

The HeartMate II (HMII) recipients were by far the most common of the 5 MCS devices, and we therefore analyzed them by themselves. We will analyze the samples associated with other devices in relation to the HeartMate II towards the end of this document.

```{r HMII_tsplot, eval = T}
require(reshape2, quietly = T)
df.HMII <- subset(df, df$`Device Type`=="HMII")
df.long <- melt(df.HMII, id.vars = colnames(df)[1:13])



names(df.long) <- make.names(names(df.long))

invisible(suppressMessages(require(Hmisc, quietly = T)))
stat_sum_df <- function(fun, geom="errorbar", ...) {
    stat_summary(fun.data = fun, geom = geom, width = 1, ...)
}

plots.ts <- mclapply(unique(df.long$variable), function(this_var){
    lapply(groups, function(this_groups){
        this_df <- subset(df.long, df.long$variable == this_var)
        ggplot(this_df) +
            aes(x = Time, y = value, group = PatientID) +
            aes_string(color = this_groups, fill = this_groups) +
            geom_line(alpha = 0.2) + 
            geom_point(alpha = 0.1) + 
            #stat_smooth(aes_string(group = this_groups), method = "loess", span = 1) +
            stat_summary(fun.y = mean, aes_string(group = this_groups), geom=c("point"), position = position_dodge(.5)) + 
            stat_summary(fun.y = mean, aes_string(group = this_groups), geom=c("line"), size = 2, position = position_dodge(.5)) + 
            stat_smooth(method = "loess", aes_string(group = this_groups), size = .01, span = 1, alpha = 0.1) + 
            stat_sum_df(function(x) mean_cl_normal(x, conf.int = 0.68), mapping = aes_string(group = this_groups), position = position_dodge(.5)) + 
            scale_color_aaas() + scale_fill_aaas() +
            xlab("Time (days after surgery)") +
            ylab(this_var) + 
            scale_x_continuous(breaks = unique(this_df$Time)) +
            ggtitle(paste(this_var)) +
            theme_classic()
    })
}, mc.cores = detectCores()-1)
names(plots.ts) <- unique(df.long$variable)

# for(ii in c(1:length(plots.ts))){
#     for(jj in 1:length(plots.ts[[ii]])){
#         suppressWarnings(print(plots.ts[[ii]][[jj]]))
#     }
# } 

```

## PCA {.tabset .tabset-fade .tabset-pills}

We observed large variability between individual patients, compared to the variability within individual patients. The first principal component appears to be associated with VAD Indication; the second principal component looks weakly associated with time.


```{r PCA_HMII, eval = T}
suppressMessages(require(ggbiplot, quietly = T))
require(ggsci, quietly = T)

# Efron's double standardization
double_standardize <- function(x, niter = 100) {
    for(i in 1:niter) x <- t(scale(t(scale(x))))
    return(as.data.frame(x))
}

isna <- unique(unlist(apply(df.HMII[,bcellcyto], 2, function(x) which(is.na(x)))))
pca <- prcomp(double_standardize(df.HMII[-isna, bcellcyto]), center = TRUE, scale. = TRUE)

require(factoextra, quietly = T)
g.scree <- fviz_screeplot(pca, ncp = 20)

# Contributions of variables to PC1
g.1 <- fviz_contrib(pca, choice = "var", axes = 1, top = 10, sort.val = "asc") + coord_flip()
# Contributions of variables to PC2
g.2 <- fviz_contrib(pca, choice = "var", axes = 2, top = 10, sort.val = "asc") + coord_flip()
# Contributions of variables to PC3
g.3 <- fviz_contrib(pca, choice = "var", axes = 3, top = 10, sort.val = "asc") + coord_flip()
# Contributions of variables to PC4
g.4 <- fviz_contrib(pca, choice = "var", axes = 4, top = 10, sort.val = "asc") + coord_flip()

print(g.scree)
print(g.1)
print(g.2)
#print(g.3)
#print(g.4)
```



```{r, results='asis'}

colorfun <- function(grouping, ...){
    if(nlevels(factor(grouping)) > 10) scale_color_discrete(...)
    if(nlevels(factor(grouping)) <=10) scale_color_d3(...)
} 

plots.pca <- mclapply(names(df.HMII)[1:13], function(this_var){
    this_groups <- df.HMII[-isna, this_var]
    if(is.numeric(this_groups)) this_groups <- cut(this_groups, 4)
    
    ggbiplot(pca,
             groups = this_groups,
             ellipse = TRUE,
             alpha = 0.3,
             varname.size = 1.2) + 
        colorfun(this_groups, name = this_var) +
        ggtitle(paste0(this_var, " variability")) +
        theme_classic() 
}, mc.cores = detectCores()-1)

names(plots.pca) <- names(df.HMII)[1:13]
#plots.pca$PatientID
#plots.pca$`Device Type`

for(ii in 1:length(plots.pca)){
    cat("  \n###", names(plots.pca)[ii], "\n")
    suppressWarnings(print(plots.pca[[ii]]))
    cat("  \n")
}

```




## Categorical associations {.tabset .tabset-fade .tabset-pills}

We analyzed the categorical variables for pairwise correlations using Fisher's exact test.


### Survival

We computed odds ratios associated with survival.

```{r survival_metadata_2, message=FALSE}
df.HMII.factors <- df.HMII[match(levels(df.HMII$PatientID), df.HMII$PatientID),]
isfactor <- which(sapply(df.HMII.factors, is.factor))[-1]
contingency <- lapply(isfactor[!(names(isfactor) %in% c("Survival","Outcome", "LowIntermacs"))], 
                      function(this_factor){
                          table(df.HMII.factors[,this_factor], df.HMII.factors$Survival)
                      })

fisher.p <- sapply(contingency, function(this_table){
    ft <- fisher.test(this_table)
    ft$p
})

fisher.OR.0 <- lapply(contingency, function(this_table){
    ft <- fisher.test(this_table)
    if(is.null(ft$estimate)) {
        ft$estimate <- NA
        ft$conf.int <- c(NA,NA)
    }
    ret <- list(OR = ft$estimate, lowerCL = ft$conf.int[1], upperCL = ft$conf.int[2])
    return(ret)
})
fisher.OR <- as.data.frame(do.call(rbind, fisher.OR.0))
fisher.OR$pvalue <- fisher.p
fisher.OR$qvalue <- p.adjust(fisher.p, method = "BH")
fisher.all <- as.data.frame(sapply(fisher.OR, as.numeric))
rownames(fisher.all) <- rownames(fisher.OR)

qtable <- signif(fisher.all[order(fisher.all$pvalue),],3)

qtable %>%
    mutate(
        `Factor` = row.names(.),
        pvalue = cell_spec(pvalue, color = ifelse(qtable$pvalue > 0.05, "grey", "red")),
        qvalue = cell_spec(qvalue, color = ifelse(qtable$qvalue > 0.05, "grey", "red"))
    ) %>% 
    kable(escape = F, row.names = T) %>%
    kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                  font_size = 12)
```

### InterMACS

We computed odds ratios associated with the InterMACS score.

```{r intermacsbin_metadata_2, message=FALSE}
isfactor <- which(sapply(df.HMII, is.factor))[-1]
contingency <- lapply(isfactor[!(names(isfactor) %in% c("LowIntermacs", "InterMACS"))], 
                      function(this_factor){
                          table(df.HMII.factors[,this_factor], df.HMII.factors$LowIntermacs)
                      })

fisher.p <- sapply(contingency, function(this_table){
    ft <- fisher.test(this_table, simulate.p.value = F, B = 10000)
    ft$p
})

fisher.OR.0 <- lapply(contingency, function(this_table){
    ft <- fisher.test(this_table, simulate.p.value = F, B = 10000)
    if(is.null(ft$estimate)) {
        ft$estimate <- NA
        ft$conf.int <- c(NA,NA)
    }
    ret <- list(OR = ft$estimate, lowerCL = ft$conf.int[1], upperCL = ft$conf.int[2])
    return(ret)
})
fisher.OR <- as.data.frame(do.call(rbind, fisher.OR.0))
fisher.OR$pvalue <- fisher.p
fisher.OR$qvalue <- p.adjust(fisher.p, method = "BH")
fisher.all <- as.data.frame(sapply(fisher.OR, as.numeric))
rownames(fisher.all) <- rownames(fisher.OR)

qtable <- signif(fisher.all[order(fisher.all$pvalue),],3)

qtable %>%
    mutate(
        `Factor` = row.names(.),
        pvalue = cell_spec(pvalue, color = ifelse(qtable$pvalue > 0.05, "grey", "red")),
        qvalue = cell_spec(qvalue, color = ifelse(qtable$qvalue > 0.05, "grey", "red"))
    ) %>% 
    kable(escape = F, row.names = T) %>%
    kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                  font_size = 12)
```


### Sensitization

We computed odds ratios associated with sensitization.

```{r sensitization_metadata_2, message=FALSE}
isfactor <- which(sapply(df.HMII, is.factor))[-1]
contingency <- lapply(isfactor[!(names(isfactor) %in% c("Sensitized"))], 
                      function(this_factor){
                          table(df.HMII.factors[,this_factor], df.HMII.factors$Sensitized)
                      })

fisher.p <- sapply(contingency, function(this_table){
    ft <- fisher.test(this_table)
    ft$p
})

fisher.OR.0 <- lapply(contingency, function(this_table){
    ft <- fisher.test(this_table)
    if(is.null(ft$estimate)) {
        ft$estimate <- NA
        ft$conf.int <- c(NA,NA)
    }
    ret <- list(OR = ft$estimate, lowerCL = ft$conf.int[1], upperCL = ft$conf.int[2])
    return(ret)
})
fisher.OR <- as.data.frame(do.call(rbind, fisher.OR.0))
fisher.OR$pvalue <- fisher.p
fisher.OR$qvalue <- p.adjust(fisher.p, method = "BH")
fisher.all <- as.data.frame(sapply(fisher.OR, as.numeric))
rownames(fisher.all) <- rownames(fisher.OR)

qtable <- signif(fisher.all[order(fisher.all$pvalue),],3)

qtable %>%
    mutate(
        `Factor` = row.names(.),
        pvalue = cell_spec(pvalue, color = ifelse(qtable$pvalue > 0.05, "grey", "red")),
        qvalue = cell_spec(qvalue, color = ifelse(qtable$qvalue > 0.05, "grey", "red"))
    ) %>% 
    kable(escape = F, row.names = T) %>%
    kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                  font_size = 12)
```




### Sex

We computed odds ratios associated with sex.

```{r sex_metadata_2, message=FALSE}
isfactor <- which(sapply(df.HMII, is.factor))[-1]
contingency <- lapply(isfactor[!(names(isfactor) %in% c("Sex"))], 
                      function(this_factor){
                          table(df.HMII.factors[,this_factor], df.HMII.factors$Sex)
                      })

fisher.p <- sapply(contingency, function(this_table){
    ft <- fisher.test(this_table, simulate.p.value = F, B = 10000)
    ft$p
})

fisher.OR.0 <- lapply(contingency, function(this_table){
    ft <- fisher.test(this_table, simulate.p.value = F, B = 10000)
    if(is.null(ft$estimate)) {
        ft$estimate <- NA
        ft$conf.int <- c(NA,NA)
    }
    ret <- list(OR = ft$estimate, lowerCL = ft$conf.int[1], upperCL = ft$conf.int[2])
    return(ret)
})
fisher.OR <- as.data.frame(do.call(rbind, fisher.OR.0))
fisher.OR$pvalue <- fisher.p
fisher.OR$qvalue <- p.adjust(fisher.p, method = "BH")
fisher.all <- as.data.frame(sapply(fisher.OR, as.numeric))
rownames(fisher.all) <- rownames(fisher.OR)

qtable <- signif(fisher.all[order(fisher.all$pvalue),],3)

qtable %>%
    mutate(
        `Factor` = row.names(.),
        pvalue = cell_spec(pvalue, color = ifelse(qtable$pvalue > 0.05, "grey", "red")),
        qvalue = cell_spec(qvalue, color = ifelse(qtable$qvalue > 0.05, "grey", "red"))
    ) %>% 
    kable(escape = F, row.names = T) %>%
    kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                  font_size = 12)
```

### Age

We computed odds ratios associated with age.

```{r age_metadata_2, message=FALSE}
isfactor <- which(sapply(df.HMII, is.factor))[-1]
contingency <- lapply(isfactor[!(names(isfactor) %in% c("AgeGreater60"))], 
                      function(this_factor){
                          table(df.HMII.factors[,this_factor], df.HMII.factors$AgeGreater60)
                      })

fisher.p <- sapply(contingency, function(this_table){
    ft <- fisher.test(this_table, simulate.p.value = F, B = 10000)
    ft$p
})

fisher.OR.0 <- lapply(contingency, function(this_table){
    ft <- fisher.test(this_table, simulate.p.value = F, B = 10000)
    if(is.null(ft$estimate)) {
        ft$estimate <- NA
        ft$conf.int <- c(NA,NA)
    }
    ret <- list(OR = ft$estimate, lowerCL = ft$conf.int[1], upperCL = ft$conf.int[2])
    return(ret)
})
fisher.OR <- as.data.frame(do.call(rbind, fisher.OR.0))
fisher.OR$pvalue <- fisher.p
fisher.OR$qvalue <- p.adjust(fisher.p, method = "BH")
fisher.all <- as.data.frame(sapply(fisher.OR, as.numeric))
rownames(fisher.all) <- rownames(fisher.OR)

qtable <- signif(fisher.all[order(fisher.all$pvalue),],3)

qtable %>%
    mutate(
        `Factor` = row.names(.),
        pvalue = cell_spec(pvalue, color = ifelse(qtable$pvalue > 0.05, "grey", "red")),
        qvalue = cell_spec(qvalue, color = ifelse(qtable$qvalue > 0.05, "grey", "red"))
    ) %>% 
    kable(escape = F, row.names = T) %>%
    kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                  font_size = 12)
```

### VAD Indication

We computed odds ratios associated with VAD Indication.

```{r vad_metadata_2, message=FALSE}
isfactor <- which(sapply(df.HMII, is.factor))[-1]
contingency <- lapply(isfactor[!(names(isfactor) %in% c("VAD Indication"))], 
                      function(this_factor){
                          table(df.HMII.factors[,this_factor], df.HMII.factors$`VAD Indication`)
                      })

fisher.p <- sapply(contingency, function(this_table){
    ft <- fisher.test(this_table, simulate.p.value = F, B = 10000)
    ft$p
})

fisher.OR.0 <- lapply(contingency, function(this_table){
    ft <- fisher.test(this_table, simulate.p.value = F, B = 10000)
    if(is.null(ft$estimate)) {
        ft$estimate <- NA
        ft$conf.int <- c(NA,NA)
    }
    ret <- list(OR = ft$estimate, lowerCL = ft$conf.int[1], upperCL = ft$conf.int[2])
    return(ret)
})
fisher.OR <- as.data.frame(do.call(rbind, fisher.OR.0))
fisher.OR$pvalue <- fisher.p
fisher.OR$qvalue <- p.adjust(fisher.p, method = "BH")
fisher.all <- as.data.frame(sapply(fisher.OR, as.numeric))
rownames(fisher.all) <- rownames(fisher.OR)

qtable <- signif(fisher.all[order(fisher.all$pvalue),],3)

qtable %>%
    mutate(
        `Factor` = row.names(.),
        pvalue = cell_spec(pvalue, color = ifelse(qtable$pvalue > 0.05, "grey", "red")),
        qvalue = cell_spec(qvalue, color = ifelse(qtable$qvalue > 0.05, "grey", "red"))
    ) %>% 
    kable(escape = F, row.names = T) %>%
    kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                  font_size = 12)
```


### RVAD

We computed odds ratios associated with RVAD.

```{r rvad_metadata_2, message=FALSE}
isfactor <- which(sapply(df.HMII, is.factor))[-1]
contingency <- lapply(isfactor[!(names(isfactor) %in% c("RVAD"))], 
                      function(this_factor){
                          table(df.HMII.factors[,this_factor], df.HMII.factors$RVAD)
                      })

fisher.p <- sapply(contingency, function(this_table){
    ft <- fisher.test(this_table)
    ft$p
})

fisher.OR.0 <- lapply(contingency, function(this_table){
    ft <- fisher.test(this_table)
    if(is.null(ft$estimate)) {
        ft$estimate <- NA
        ft$conf.int <- c(NA,NA)
    }
    ret <- list(OR = ft$estimate, lowerCL = ft$conf.int[1], upperCL = ft$conf.int[2])
    return(ret)
})
fisher.OR <- as.data.frame(do.call(rbind, fisher.OR.0))
fisher.OR$pvalue <- fisher.p
fisher.OR$qvalue <- p.adjust(fisher.p, method = "BH")
fisher.all <- as.data.frame(sapply(fisher.OR, as.numeric))
rownames(fisher.all) <- rownames(fisher.OR)

qtable <- signif(fisher.all[order(fisher.all$pvalue),],3)

qtable %>%
    mutate(
        `Factor` = row.names(.),
        pvalue = cell_spec(pvalue, color = ifelse(qtable$pvalue > 0.05, "grey", "red")),
        qvalue = cell_spec(qvalue, color = ifelse(qtable$qvalue > 0.05, "grey", "red"))
    ) %>% 
    kable(escape = F, row.names = T) %>%
    kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                  font_size = 12)
```





## Conditional distributions of categories

We used the `GGally` package to visualize conditional distributions for the categorical variables.

```{r ggpairs_2, fig.height=10, message=FALSE, warning=FALSE}
df.HMII.temp <- df.HMII.factors
colnames(df.HMII.temp) <- make.names(colnames(df.HMII), unique = T)
#invisible(
suppressWarnings(
    suppressMessages(
        suppressWarnings(ggpairs(df.HMII.temp, 
                #mapping = aes(color = Survival), 
                columns = colnames(df.HMII.temp)[c(3,5,6,7,8,9,10,12,13)]) +
            ggplot2::theme_grey(base_size = 7)
    )))
#)
```



## Identification of clusters

We double-standardized the data ( [Efron 2009](https://projecteuclid.org/euclid.aoas/1254773272)) and computed the correlation matrix for the biomarkers using all pairwise complete data. We then clustered the biomarkers using those correlations, and clustered the samples that remained after removing missing data. 

```{r sample_correlation_heatmap_2, message=F}
require(pheatmap, quietly = T)
require(RColorBrewer, quietly = T)

missing.ix <- Reduce(intersect, apply(df.HMII[,bcellcyto], 2, function(x) which(is.na(x))))
df.HMII.raw <- df.HMII[-missing.ix,]

colorfun <- function(nlevels, func = pal_d3, ...){
    if(nlevels > 10) return(standardColors(nlevels))
    if(nlevels <=10) return(func(...)(nlevels))
} 

annotation.row <- data.frame("biomarker" = factor(c(rep("B-cell",29), rep("cytokine",38))))
annotation.col <- df.HMII.raw[,c(1,4,5,6,7,8,9,10,12,13)]
annotation.colors <- lapply(colnames(annotation.col), function(nam){
    colrs <- colorfun(nlevels(annotation.col[[nam]]))
    names(colrs) <- levels(annotation.col[[nam]])
    return(colrs)
})
names(annotation.colors) <- colnames(annotation.col)
annotation.colors[["biomarker"]] <- colorfun(nlevels(annotation.row$biomarker))
names(annotation.colors[["biomarker"]]) <- levels(annotation.row$biomarker)

df.HMII.raw.ds <- df.HMII.raw
df.HMII.raw.ds[,bcellcyto] <- double_standardize(df.HMII.raw[,c(bcellcyto)])
df.HMII.patient <- t(na.omit(double_standardize((df.HMII.raw[,bcellcyto]))))
rownames(annotation.row) <- rownames(df.HMII.patient)


require(factoextra, quietly = T)
require(NbClust, quietly = T)

# biomarker clusters
r.biomarker <- cor(df.HMII.raw.ds[,bcellcyto], use = "p")
fviz_nbclust(t(df.HMII.raw.ds[,bcellcyto]), hcut, method = c("silhouette"),diss = as.dist((1-r.biomarker)/2), k.max = 25)+
  labs(subtitle = "Silhouette method")
# fviz_nbclust(t(df.HMII.raw.ds[,bcellcyto]), hcut, method = c("wss"),diss = as.dist((1-r.biomarker)/2), k.max = 25)+
#   labs(subtitle = "Elbow method")
# fviz_nbclust(t(na.omit(df.HMII.raw.ds[,bcellcyto])), hcut, method = c( "gap_stat"), diss = as.dist((1-r.biomarker)/2), k.max = 25)+
#   labs(subtitle = "Gap statistic method")

# sample clusters
# fviz_nbclust(t(df.HMII.patient), hcut, method = c("silhouette"), k.max = 25)+
#   labs(subtitle = "Silhouette method")
# fviz_nbclust(df.HMII.patient, hcut, method = c("wss"), k.max = 25)+
#   labs(subtitle = "Elbow method")
# fviz_nbclust(df.HMII.patient, hcut, method = c( "gap_stat"), k.max = 25)+
#   labs(subtitle = "Gap statistic method")

tree <- hclust(as.dist((1-r.biomarker)/2), method = "ward.D2")
#pheatmap(t(df.HMII.raw.ds[,bcellcyto]), cluster_rows=tree, cutree_rows = 17, border_color = NA, cluster_cols = F)
p1 <- pheatmap(df.HMII.patient, clustering_method = "ward.D2", cluster_rows = tree, cutree_rows = 17, cutree_cols = 4, border_color = NA, silent = T)

```

```{r, message = F, fig.height=10}

# original
#p1 <- pheatmap(df.HMII.patient, clustering_method = "ward.D2", cutree.rows = 4, cutree_cols = 4, silent = TRUE)
bicluster <- list()
bicluster$biomarkers <- cutree(p1$tree_row, k=7)
bicluster$biomarkers_optimal <- cutree(p1$tree_row, k=19)
bicluster$samples <- cutree(p1$tree_col, k=2)
annotation.row$cluster <- factor(bicluster$biomarkers)
annotation.row$cluster_optimal <- factor(bicluster$biomarkers_optimal)
annotation.colors$cluster <- colorfun(nlevels(annotation.row$cluster), func = pal_simpsons)
names(annotation.colors$cluster) <- levels(factor(annotation.row$cluster))
annotation.colors$cluster_optimal <- colorfun(nlevels(annotation.row$cluster_optimal), func = pal_simpsons)
names(annotation.colors$cluster_optimal) <- levels(factor(annotation.row$cluster_optimal))
#bicluster$annotation.colors <- annotation.colors$cluster
bicluster$annotation.colors <- list(cluster = annotation.colors$cluster, cluster_optimal = annotation.colors$cluster_optimal)

pheatmap(df.HMII.patient, 
         color = colorRampPalette(rev(brewer.pal(n = 10, name = "RdBu")))(100),
         breaks = c(seq(-max(abs(df.HMII.patient), na.rm=T), 0, length.out = 50), seq(0.001, max(abs(df.HMII.patient), na.rm=T), length.out = 50)),
         #scale = "row",
         clustering_distance_rows = "euclidean",
         clustering_distance_cols = "euclidean",
         fontsize = 7,
         cutree_rows = 19,
         cutree_cols = 2,
         cluster_cols = T,
         cluster_rows = tree,
         show_colnames = F,
         annotation_col = annotation.col,
         annotation_row = annotation.row,
         annotation_colors = annotation.colors,
         clustering_method = "ward.D2"
)
```





## Clusters over time  {.tabset .tabset-fade .tabset-pills}

```{r, warning=FALSE, message=FALSE}
df.HMII.raw.ds.long <- melt(df.HMII.raw.ds, id.vars = colnames(df)[1:13])

make_long_with_clusterID <- function(dataframe, form, cluster, func = function(x) mean(x, na.rm=T)){
    colnames(dataframe) <- make.names(colnames(dataframe))
    this_df <- aggregate(form, data = dataframe, FUN = func)
    this_df$cluster <- cluster[match(this_df$variable, names(cluster))]
    return(this_df)
}

stat_sum_df <- function(fun, geom="errorbar", ...) {
    stat_summary(fun.data = fun, geom = geom, width = 1, ...)
}

this_formula <- as.formula(paste0("value~variable*Time"))
this_df <- make_long_with_clusterID(df.HMII.raw.ds.long, 
                                        this_formula,
                                        bicluster$biomarkers)

g <- ggplot(this_df) + 
        aes(x=as.numeric(as.character(Time)), y=value, 
            color = factor(cluster), fill = factor(cluster), group = variable) + 
        #geom_point(alpha = 0.1, size = 1) + 
        #geom_line(alpha = 0.2) +
        xlab("Time (days)") +
        ylab("Standardized level (z-score)") +
        scale_x_continuous(breaks = unique(this_df$Time)) +
        #ggtitle(this_factor) +
        #stat_summary(fun.y = mean, aes(group = cluster), geom=c("line"), size = .02, position = position_dodge(.5)) +
        stat_smooth(method = "loess", aes(group = cluster), span = .5, size = 1, alpha = 0.0) +
        stat_summary(fun.y = mean, aes(group = cluster), geom=c("point"), position = position_dodge(.5)) +
        stat_sum_df(function(x) mean_cl_normal(x, conf.int = 0.68), mapping = aes(group = cluster), position = position_dodge(.5)) + 
        scale_color_simpsons(name = "Cluster") + scale_fill_simpsons(name = "Cluster") + 
        theme_classic() 
#print(g)


g2 <- ggplot(this_df) + 
        aes(x=as.numeric(as.character(Time)), y=value, 
            color = factor(cluster), fill = factor(cluster), group = variable) + 
        #geom_point(alpha = 0.1, size = 1) + 
        #geom_line(alpha = 0.2) +
        xlab("Time (days)") +
        ylab("Standardized level (z-score)") +
        scale_x_continuous(breaks = unique(this_df$Time)) +
        #ggtitle(this_factor) +
        stat_summary(fun.y = mean, aes(group = cluster), geom=c("line"), size = .02, position = position_dodge(.5)) +
        stat_smooth(method = "loess", aes(group = cluster), span = .5, size = 1, alpha = 0.1) +
        stat_summary(fun.y = mean, aes(group = cluster), geom=c("point"), position = position_dodge(.5)) +
        stat_sum_df(function(x) mean_cl_normal(x, conf.int = 0.68), mapping = aes(group = cluster), position = position_dodge(.5)) + 
        scale_color_simpsons(name = "Cluster") + scale_fill_simpsons(name = "Cluster") + 
        theme_classic() 
#print(g2)

g3 <- ggplot(this_df) + 
        aes(x=as.numeric(as.character(Time)), y=value, 
            color = factor(cluster), fill = factor(cluster), group = variable) + 
        geom_point(alpha = 0.1, size = 1) + 
        geom_line(alpha = 0.2) +
        xlab("Time (days)") +
        ylab("Standardized level (z-score)") +
        scale_x_continuous(breaks = unique(this_df$Time)) +
        #ggtitle(this_factor) +
        stat_summary(fun.y = mean, aes(group = cluster), geom=c("line"), size = .02, position = position_dodge(.5)) +
        stat_smooth(method = "loess", aes(group = cluster), span = .5, size = 1, alpha = 0.1) +
        stat_summary(fun.y = mean, aes(group = cluster), geom=c("point"), position = position_dodge(.5)) +
        stat_sum_df(function(x) mean_cl_normal(x, conf.int = 0.68), mapping = aes(group = cluster), position = position_dodge(.5)) + 
        scale_color_simpsons(name = "Cluster") + scale_fill_simpsons(name = "Cluster") + 
        theme_classic() 
print(g3)

```


We analyzed the difference between categories for each cluster, using a paired t-test at each timepoint to pick out interesting differences. We label the biomarkers for tests that have Benjamini-Hochberg $q<0.05$.


```{r, results='asis', warning=F, message=F, fig.height=20}
require(ggrepel, quietly = TRUE)

presult <- list()
for(this_factor in groups){
    this_formula <- as.formula(paste0("value~variable*Time*", make.names(this_factor)))
    this_df <- make_long_with_clusterID(df.HMII.raw.ds.long, 
                                        this_formula,
                                        bicluster$biomarkers)
    this_df$name <- as.character(this_df$variable )
    
    # compute t-tests
    presult[[this_factor]] <- lapply(split(this_df, this_df$cluster), function(x){
        lapply(split(x, as.factor(x$Time)), function(y){
            n <- table(y[[make.names(this_factor)]])
            if(all(n > 1) & length(n)==2){
                #res <- t.test(as.formula(paste0("value ~ ", make.names(this_factor))), paired = TRUE, data = y)
                #t <- res$statistic
                #p <- res$p.value
                
                require(lmerTest, quietly = T)
                lme <- lmer(as.formula(paste0("value ~ ", make.names(this_factor), " + (1|name)")), data = y)
                lme.aov <- anova(lme)
                p <- lme.aov$`Pr(>F)`
                
            } else {
                t <- 0
                p <- 1
            }
           return(p)
        })  
    }) 
}

#hist(unlist(presult))
q <- p.adjust(unlist(presult), method = "BH")
q_factor <- sapply(str_split(names(q), "[.]"), function(x) x[1])
q_clusters <- sapply(str_split(names(q), "[.]"), function(x) x[2])
q_time <- sapply(str_split(names(q), "[.]"), function(x) x[3])
these_qvals <- data.frame(qval = q, factor = q_factor, cluster = q_clusters, Time = q_time)

for(this_factor in groups){
    this_formula <- as.formula(paste0("value~variable*Time*", make.names(this_factor)))
    this_df <- make_long_with_clusterID(df.HMII.raw.ds.long,
                                        this_formula,
                                        bicluster$biomarkers)
    this_df$name <- as.character(this_df$variable )
    # 
    # # compute t-tests
    # presult <- lapply(split(this_df, this_df$cluster), function(x){
    #     lapply(split(x, as.factor(x$Time)), function(y){
    #         n <- table(y[[make.names(this_factor)]])
    #         if(all(n > 1) & length(n)==2){
    #             res <- t.test(as.formula(paste0("value ~ ", make.names(this_factor))), paired = TRUE, data = y)
    #             t <- res$statistic
    #             p <- res$p.value
    #         } else {
    #             t <- 0
    #             p <- 1
    #         }
    #        return(p)
    #     })  
    # }) 
    # 
    # require(stringr, quietly = T)
    # q <- p.adjust(unlist(presult), method = "BH")
    # q_clusters <- sapply(str_split(names(q), "[.]"), function(x) x[1])
    # q_time <- sapply(str_split(names(q), "[.]"), function(x) x[2])
    # these_qvals <- data.frame(qval = q, cluster = q_clusters, Time = q_time)
    
    # label only significant differences
    for(this_cluster in levels(factor(this_df$cluster))){
        # this_pvals <- presult[[this_cluster]]
        # this_qvals <- p.adjust(this_pvals, method = "bonferroni")
        #pos <- this_qvals < 0.05
        for(this_time in levels(factor(this_df$Time))){
            this_qval <- these_qvals$qval[these_qvals$factor == this_factor & these_qvals$cluster == this_cluster & these_qvals$Time == this_time]
            #this_qval <- these_qvals[[this_factor]]$qval[these_qvals$cluster == this_cluster & these_qvals$Time == this_time]
            #ii <- which(names(this_qvals) == this_time)
            if(length(this_qval) > 0){
                if(this_qval < 0.05){
                    this_df$name[this_df$cluster == this_cluster & this_df$Time == this_time & this_df[[this_factor]] == levels(this_df[[this_factor]])[1]] <- ""
                } else {
                    this_df$name[this_df$cluster == this_cluster & this_df$Time == this_time] <- ""
                }
            } else {
                next()
            }
        }
    }
    
    g <- ggplot(this_df) + 
        aes(x=as.numeric(as.character(Time)), y=value, 
            color = factor(cluster), fill = factor(cluster), label = name) + 
        aes_string(group = paste("interaction(variable,", make.names(this_factor), ")"), lty = make.names(this_factor)) +
        geom_point(alpha = 0.1, size = 1) + 
        geom_line(alpha = 0.2) +
        xlab("Time (days)") +
        ylab("Standardized level (z-score)") +
        scale_x_continuous(breaks = unique(this_df$Time)) +
        ggtitle(this_factor) +
        #stat_smooth(method = "loess", aes_string(group = make.names(this_factor)), span = .6, alpha = 0.3) +
        stat_summary(fun.y = mean, aes_string(group = make.names(this_factor)), geom=c("line"), size = .02, position = position_dodge(.5)) +
        stat_smooth(method = "loess", aes_string(group = make.names(this_factor)), span = .6, size = 1, alpha = 0.3) +
        stat_summary(fun.y = mean, aes_string(group = make.names(this_factor)), geom=c("point"), position = position_dodge(.5)) +
        stat_sum_df(function(x) mean_cl_boot(x, conf.int = 0.68), mapping = aes_string(group = make.names(this_factor)), position = position_dodge(.5)) + 
        scale_color_simpsons(name = "Cluster") + scale_fill_simpsons(name = "Cluster") + 
        geom_text_repel(aes(as.numeric(as.character(Time)), value), 
                         size = 1.5, 
                         fontface = 'bold', 
                         color = 'black',
                         segment.alpha = 0.2,
                         alpha = 1) +
        theme_classic() +
        facet_grid(cluster~., scales = "free")
    
    
    
     cat("  \n###", this_factor, "\n")
    
    print(g)
    
    cat("  \n")
}


```



## Temporal patterns

After double-standardizing the data, we clustered the biomarkers according to their temporal patterns. They formed 4 main clusters.

```{r temporal_clusters, warning=F, message=F}
df.ds <- df.HMII
df.ds[,bcellcyto] <-  double_standardize(df.HMII[,bcellcyto])
df.ds.patients.0 <- split(df.ds, df.ds$PatientID)

df.ds.patients <- lapply(df.ds.patients.0, function(this_patient) this_patient[match(c(0,1,3,5,8,14,21), this_patient$Time),bcellcyto])

varnames <- colnames(df.ds[,bcellcyto])
meanlist <- lapply(varnames, function(this_var){
    temp <- aggregate(df.ds[[this_var]], 
              list(df.ds$Time), 
              FUN = function(x) mean(x, na.rm = T))
    colnames(temp) <- c("Time", "z")
    temp$Molecule <- this_var
    temp
})
names(meanlist) <- varnames

means.long <- do.call(rbind, meanlist)
means.wide <- dcast(means.long, Time~Molecule, value.var = "z" )

colorfun <- function(nlevels, ...){
    if(nlevels > 10) return(standardColors(nlevels))
    if(nlevels <=10) return(pal_d3(...)(nlevels))
} 
annotation.row <- data.frame("biomarker" = factor(c(rep("B-cell",29), rep("cytokine",38))))

annotation.colors <- lapply(colnames(annotation.row), function(nam){
    colrs <- colorfun(nlevels(annotation.row[[nam]]))
    names(colrs) <- levels(annotation.row[[nam]])
    return(colrs)
})
names(annotation.colors) <- colnames(annotation.row)

df.means <- as.data.frame(t(means.wide[,-1]))
rownames(annotation.row) <- rownames(df.means)
invisible(ph <- pheatmap(df.means, 
         color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(100),
         breaks = c(seq(-max(abs(df.means), na.rm=T), 0, length.out = 50), seq(0.001, max(abs(df.means), na.rm=T), length.out = 50)),
         #scale = "row",
         fontsize = 7,
         cutree_rows = 4,
         cutree_cols = 1,
         cluster_cols = F,
         cluster_rows = T,
         #annotation_col = annotation.col,
         annotation_row = annotation.row,
         annotation_colors = annotation.colors,
         clustering_method = "ward.D2",
         labels_col = means.wide$Time,
         border_color = NA,
         main = "Temporal Clusters",
         silent = T
         
))
#print(ph)

fviz_nbclust(df.means, hcut, method = c("silhouette"), diss = as.dist((1-cor(t(df.means), use = "p"))/2), k.max = 25)+
  labs(subtitle = "Silhouette method")
# fviz_nbclust(df.means, hcut, method = c("wss"), k.max = 25)+
  # labs(subtitle = "Elbow method")
# fviz_nbclust(df.means, hcut, method = c( "gap_stat"), k.max = 25)+
#   labs(subtitle = "Gap statistic method")

cluster <- cutree(ph$tree_row, k=4)
annotation.row$time_cluster <- cluster
annotation.colors$time_cluster <- colorfun(nlevels(factor(annotation.row$time_cluster)))
names(annotation.colors$time_cluster) <- factor(unique(annotation.row$time_cluster))

# add in clusters from the first clustering
annotation.row$bicluster <- bicluster$biomarkers
annotation.row$bicluster_optimal <- bicluster$biomarkers_optimal
annotation.colors$bicluster <- bicluster$annotation.colors$cluster
annotation.colors$bicluster_optimal <- bicluster$annotation.colors$cluster_optimal

```


```{r, warning = F, message = F, fig.height = 9}

ph2 <- pheatmap(df.means, 
         color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(100),
         breaks = c(seq(-max(abs(df.means), na.rm=T), 0, length.out = 50), seq(0.001, max(abs(df.means), na.rm=T), length.out = 50)),
         #scale = "row",
         fontsize = 7,
         cutree_rows = 4,
         cutree_cols = 1,
         cluster_cols = F,
         cluster_rows = T,
         #annotation_col = annotation.col,
         annotation_row = annotation.row,
         annotation_colors = annotation.colors,
         clustering_method = "ward.D2",
         labels_col = means.wide$Time,
         border_color = NA,
         main = "Temporal Clusters"
         
)
print(ph2)


```


We depicted each biomarker cluster's temporal pattern as a smooth function of time, using a LOESS regression model. There are clear temporal dynamics occurring at multiple timescales.

```{r, warning=F, message=F}
colnames(df.means) <- unique(means.long$Time)
df.means$cluster <- factor(cluster)
df.means$Molecule <- rownames(df.means)

df.clustermeans <- melt(df.means, id.vars = c("Molecule", "cluster"), variable.name = "Time", value.name = "z")

# ggplot(df.clustermeans) + aes(x=Time, y=z, color = cluster, group=Molecule, fill = cluster) + geom_point(alpha = 0.1) + geom_line(alpha = 0.1) + stat_smooth(method = "loess", aes(group = cluster), span = .7) + 
#      scale_color_lancet() + scale_fill_lancet() + 
#     theme_classic()

ggplot(df.clustermeans) + 
    aes(x=as.numeric(as.character(Time)), y=z, 
        color = cluster, group=Molecule, fill = cluster) + 
    geom_point(alpha = 0.1, size = 1) + 
    geom_line(alpha = 0.2) +
    xlab("Time (days)") +
    ylab("Standardized level (z-score)") +
    ggtitle("Temporal Clusters") +
    scale_x_continuous(breaks = as.numeric(as.character(unique(df.clustermeans$Time)))) +
    stat_summary(fun.y = mean, aes(group = cluster), geom=c("line"), size = .02, position = position_dodge(.5)) +
    stat_smooth(method = "loess", aes(group = cluster), span = .6, size = 1, alpha = 0.2) +
    stat_summary(fun.y = mean, aes(group = cluster), geom=c("point"), position = position_dodge(.5)) +
    stat_sum_df(function(x) mean_cl_boot(x, conf.int = 0.68), mapping = aes(group = cluster), position = position_dodge(.5)) + 
    scale_color_d3() + scale_fill_d3() + 
    theme_classic()

```


## Temporal patterns across categories  {.tabset .tabset-fade .tabset-pills}

We analyzed the temporal patterns of each cluster with respect to each of the patient categories. 


```{r, results='asis', fig.height = 9}

df.ds.long <- melt(df.ds, id.vars = colnames(df)[1:13])

make_long_with_clusterID <- function(dataframe, form, cluster, func = function(x) mean(x, na.rm=T)){
    colnames(dataframe) <- make.names(colnames(dataframe))
    this_df <- aggregate(form, data = dataframe, FUN = func)
    this_df$cluster <- cluster[match(this_df$variable, names(cluster))]
    return(this_df)
}




for(this_factor in groups){
    cat("  \n###", this_factor, "\n")
    
    this_formula <- as.formula(paste0("value~variable*Time*", make.names(this_factor)))
    this_df <- make_long_with_clusterID(df.ds.long, 
                                        this_formula,
                                        cluster)
    
    this_df$name <- as.character(this_df$variable )
    
    # compute t-tests
    presult <- lapply(split(this_df, this_df$cluster), function(x){
        lapply(split(x, as.factor(x$Time)), function(y){
            n <- table(y[[make.names(this_factor)]])
            if(all(n > 1) & length(n)==2){
                # this crapped out because of missing pair
                #res <- t.test(as.formula(paste0("value ~ ", make.names(this_factor))), paired = TRUE, data = y)
                #t <- res$statistic
                #p <- res$p.value
                
                require(lmerTest, quietly = T)
                lme <- lmer(as.formula(paste0("value ~ ", make.names(this_factor), " + (1|name)")), data = y)
                lme.aov <- anova(lme)
                p <- lme.aov$`Pr(>F)`
                
            } else {
                t <- 0
                p <- 1
            }
           return(p)
        })  
    }) 
    
    require(stringr, quietly = T)
    q <- p.adjust(unlist(presult), method = "BH")
    q_clusters <- sapply(str_split(names(q), "[.]"), function(x) x[1])
    q_time <- sapply(str_split(names(q), "[.]"), function(x) x[2])
    these_qvals <- data.frame(qval = q, cluster = q_clusters, Time = q_time)
    
    # label only significant differences
    for(this_cluster in levels(factor(this_df$cluster))){
        # this_pvals <- presult[[this_cluster]]
        # this_qvals <- p.adjust(this_pvals, method = "bonferroni")
        #pos <- this_qvals < 0.05
        for(this_time in levels(factor(this_df$Time))){
            this_qval <- these_qvals$qval[these_qvals$cluster == this_cluster & these_qvals$Time == this_time]
            #ii <- which(names(this_qvals) == this_time)
            if(length(this_qval) > 0){
                if(this_qval < 0.05){
                    this_df$name[this_df$cluster == this_cluster & this_df$Time == this_time & this_df[[this_factor]] == levels(this_df[[this_factor]])[1]] <- ""
                } else {
                    this_df$name[this_df$cluster == this_cluster & this_df$Time == this_time] <- ""
                }
            } else {
                next()
            }
        }
    }
    
    
    
    g <- ggplot(this_df) + 
        aes(x=as.numeric(as.character(Time)), y=value, 
            color = factor(cluster), fill = factor(cluster), label = name) + 
        aes_string(group = paste("interaction(variable,", make.names(this_factor), ")"), lty = make.names(this_factor)) +
        geom_jitter(alpha = 0.1, size = 1) + 
        geom_line(alpha = 0.2) +
        xlab("Time (days)") +
        ylab("Standardized level (z-score)") +
        ggtitle(this_factor) +
        #stat_smooth(method = "loess", aes_string(group = make.names(this_factor)), span = .6) +
        scale_x_continuous(breaks = as.numeric(as.character(unique(this_df$Time)))) +
    stat_summary(fun.y = mean, aes_string(group = make.names(this_factor)), geom=c("line"), size = .02, position = position_dodge(.5)) +
    stat_smooth(method = "loess", aes_string(group = make.names(this_factor)), span = .6, size = 1, alpha = 0.3) +
    stat_summary(fun.y = mean, aes_string(group = make.names(this_factor)), geom=c("point"), position = position_dodge(.5)) +
    stat_sum_df(function(x) mean_cl_boot(x, conf.int = 0.68), mapping = aes_string(group = make.names(this_factor)), position = position_dodge(.5)) + 
        scale_color_d3(name = "Cluster") + scale_fill_d3(name = "Cluster") + 
        geom_text_repel(aes(as.numeric(as.character(Time)), value), 
                         size = 1.5, 
                         fontface = 'bold', 
                         color = 'black',
                         segment.alpha = 0.2,
                         alpha = 1) +
        theme_classic() +
        facet_grid(cluster~., scales = "free")
    print(g)
    
    cat("  \n")
}


```

## One-way repeated measures anova (Time) {.tabset .tabset-fade .tabset-pills}

We first analyzed the association of mean biomarker levels with time using a one-way repeated measures anova. We reported all biomarkers that had a nominally statistically significant association ($p<0.05$), while also indicating the Benjamini-Hochberg q-value.

```{r bcell_models_oneway_1, eval = T}
suppressMessages(require(lmerTest, quietly = TRUE))
suppressMessages(require(car, quietly = TRUE))
require(reshape2, quietly = TRUE)

df.lmer <- df.HMII
names(df.lmer) <- make.names(names(df.lmer), unique = TRUE)

groupvars.ix <- c(2)
groupvars <- names(df.lmer)[groupvars.ix]

bcells.ix <- c(bcellcyto)
bcells <- names(df.lmer)[bcells.ix]

models.b <- mclapply(groupvars, function(this_groupvar){
    models.bcells <- lapply(bcells, function(this_bcell){
        this_formula <- as.formula(paste0(this_bcell, " ~ ", this_groupvar, 
                                          " + (1|PatientID)"))
        suppressMessages(suppressWarnings(this_model <- lmer(this_formula, data = droplevels(df.lmer))))
        this_anova <- Anova(this_model, type = 2)
        this_pvalues <- this_anova$`Pr(>Chisq)`
        names(this_pvalues) <- rownames(this_anova)
        #return(this_pvalues)
        return(list(model = this_model,
                    pvals = this_pvalues))
    })
    names(models.bcells) <- colnames(df)[bcellcyto]
    pvalues <- do.call(rbind, lapply(models.bcells, function(x) x$pvals))
    rownames(pvalues) <- bcells
    #return(pvalues)
    return(list(model = models.bcells,
                pvals = pvalues))
}, mc.cores = detectCores()-1)
names(models.b) <- groupvars
pvals <- lapply(models.b, function(x) x$pvals)

names(pvals) <- groupvars
pvals.matrix <- do.call(cbind, lapply(pvals, function(this_pval) this_pval[,c(1)]))

#ggplot(as.data.frame(pvals.matrix))+ geom_histogram(aes(x=Time), bins = 10) + xlab("p-value") + ggtitle("p-value distribution") + theme_minimal()


# Benjamini Hochberg
# qBH <- matrix(p.adjust(as.numeric(pvals.matrix),
#                        method = "BH"),
#               nrow = nrow(pvals.matrix),
#               ncol = ncol(pvals.matrix),
#               byrow = F)
# rownames(qBH) <- rownames(pvals.matrix)
# colnames(qBH) <- colnames(pvals.matrix)
# rownames(qBH) <- names(df)[bcells.ix]
# qvalsBH.df <- melt(qBH)
# colnames(qvalsBH.df) <- c("biomarker", "parameter", "qvalue")
# qvalsBH.df.ranked <- qvalsBH.df[order(qvalsBH.df$qvalue, decreasing = F),]
# qvalsBH.df.ranked[qvalsBH.df.ranked$qvalue <= 0.3,]

# Local FDR
require(fdrtool, quietly = T)
invisible(suppressMessages(fdrobj <- fdrtool(as.numeric(pvals.matrix), statistic = "pvalue", plot = F, verbose = F)))
qvals.matrix <- matrix(fdrobj$q, nrow = nrow(pvals.matrix), ncol = ncol(pvals.matrix), byrow = F)
rownames(qvals.matrix) <- rownames(pvals.matrix)
colnames(qvals.matrix) <- colnames(pvals.matrix)
rownames(qvals.matrix) <- names(df)[bcells.ix]

pvals.df <- melt(pvals.matrix)
qvals.df <- melt(qvals.matrix)
colnames(qvals.df) <- colnames(pvals.df) <- c("biomarker", "parameter", "qvalue")
qvals.df.short <- qvals.df[pvals.df$qvalue <= 0.05,]
shortlist <- qvals.df.short[order(qvals.df.short$qvalue),]
rownames(shortlist) <- 1:nrow(shortlist)

shortlist$time_cluster <- cluster[match(shortlist$biomarker, names(cluster))]
shortlist$bi_cluster <- bicluster$biomarkers[match(shortlist$biomarker, names(bicluster$biomarkers))]
shortlist$bi_cluster_optimal <- bicluster$biomarkers_optimal[match(shortlist$biomarker, names(bicluster$biomarkers_optimal))]
shortlist$qvalue <- signif(shortlist$qvalue, 3)
shortlist %>%
    mutate(
        #biomarker = row.names(.),
        qvalue = cell_spec(qvalue, color = ifelse(shortlist$qvalue > 0.05, "grey", "red"))
    ) %>% 
    kable(digits = 3, escape = F, row.names = T) %>%
    kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                  font_size = 10) %>%
    scroll_box(width = "100%")

# time cluster
this_table <- table(category = shortlist$parameter, cluster = shortlist$time_cluster)
kable(this_table) %>% 
    kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                  font_size = 10) %>%
    scroll_box(width = "100%")

# fisher.test(this_table, simulate.p.value = T)

# kable(shortlist, 
#       digits = 3,
#       row.names = T,
#       caption = "Significant results") %>%
#     kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"),
#                   font_size = 10) %>%
#     scroll_box(width = "100%")
```


## One-way repeated measures anova (Category) {.tabset .tabset-fade .tabset-pills}

We first analyzed the association of mean biomarker levels with patient categories using a one-way repeated measures anova. This model assumes there are no temporal effects (we will include those later). We reported all biomarkers that had a nominally statistically significant association ($p<0.05$), while also indicating the Benjamini-Hochberg q-value.

```{r bcell_models_oneway, eval = T}
suppressMessages(require(lmerTest, quietly = TRUE))
suppressMessages(require(car, quietly = TRUE))
require(reshape2, quietly = TRUE)

df.lmer <- df.HMII
names(df.lmer) <- make.names(names(df.lmer), unique = TRUE)

groupvars.ix <- c(4,5,6,8,9,10,13)
groupvars <- names(df.lmer)[groupvars.ix]

bcells.ix <- c(bcellcyto)
bcells <- names(df.lmer)[bcells.ix]

models.b <- mclapply(groupvars, function(this_groupvar){
    models.bcells <- lapply(bcells, function(this_bcell){
        this_formula <- as.formula(paste0(this_bcell, " ~ ", this_groupvar, 
                                          " + (1|PatientID)"))
        suppressMessages(suppressWarnings(this_model <- lmer(this_formula, data = droplevels(df.lmer))))
        this_anova <- Anova(this_model, type = 2)
        this_pvalues <- this_anova$`Pr(>Chisq)`
        names(this_pvalues) <- rownames(this_anova)
        #return(this_pvalues)
        return(list(model = this_model,
                    pvals = this_pvalues))
    })
    names(models.bcells) <- colnames(df)[bcellcyto]
    pvalues <- do.call(rbind, lapply(models.bcells, function(x) x$pvals))
    rownames(pvalues) <- bcells
    #return(pvalues)
    return(list(model = models.bcells,
                pvals = pvalues))
}, mc.cores = detectCores()-1)
names(models.b) <- groupvars
pvals <- lapply(models.b, function(x) x$pvals)

names(pvals) <- groupvars
pvals.matrix <- do.call(cbind, lapply(pvals, function(this_pval) this_pval[,c(1)]))



# Benjamini Hochberg
# qBH <- matrix(p.adjust(as.numeric(pvals.matrix), 
#                        method = "BH"), 
#               nrow = nrow(pvals.matrix), 
#               ncol = ncol(pvals.matrix), 
#               byrow = F) 
# rownames(qBH) <- rownames(pvals.matrix)
# colnames(qBH) <- colnames(pvals.matrix)
# rownames(qBH) <- names(df)[bcells.ix]
# qvalsBH.df <- melt(qBH)
# colnames(qvalsBH.df) <- c("biomarker", "parameter", "qvalue")
# qvalsBH.df.ranked <- qvalsBH.df[order(qvalsBH.df$qvalue, decreasing = F),]
# qvalsBH.df.ranked[qvalsBH.df.ranked$qvalue <= 0.3,]

# Local FDR
require(fdrtool, quietly = T)
invisible(suppressMessages(fdrobj <- fdrtool(as.numeric(pvals.matrix), statistic = "pvalue", plot = F, verbose = F)))
qvals.matrix <- matrix(fdrobj$q, nrow = nrow(pvals.matrix), ncol = ncol(pvals.matrix), byrow = F)
rownames(qvals.matrix) <- rownames(pvals.matrix)
colnames(qvals.matrix) <- colnames(pvals.matrix)
rownames(qvals.matrix) <- names(df)[bcells.ix]

pvals.df <- melt(pvals.matrix)
qvals.df <- melt(qvals.matrix)
colnames(qvals.df) <- colnames(pvals.df) <- c("biomarker", "parameter", "qvalue")
qvals.df.short <- qvals.df[pvals.df$qvalue <= 0.05,]
shortlist <- qvals.df.short[order(qvals.df.short$qvalue),]
rownames(shortlist) <- 1:nrow(shortlist)

shortlist$time_cluster <- cluster[match(shortlist$biomarker, names(cluster))]
shortlist$bi_cluster <- bicluster$biomarkers[match(shortlist$biomarker, names(bicluster$biomarkers))]
shortlist$bi_cluster_optimal <- bicluster$biomarkers_optimal[match(shortlist$biomarker, names(bicluster$biomarkers_optimal))]
shortlist$qvalue <- signif(shortlist$qvalue, 3)
shortlist %>%
    mutate(
        #biomarker = row.names(.),
        qvalue = cell_spec(qvalue, color = ifelse(shortlist$qvalue > 0.05, "grey", "red"))
    ) %>% 
    kable(digits = 3, escape = F, row.names = T) %>%
    kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                  font_size = 10) %>%
    scroll_box(width = "100%")

this_table <- table(category = shortlist$parameter, cluster = shortlist$time_cluster)
kable(this_table) %>% 
    kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                  font_size = 10) %>%
    scroll_box(width = "100%")

fisher.test(this_table, simulate.p.value = T)

# kable(shortlist, 
#       digits = 3,
#       row.names = T,
#       caption = "Significant results") %>%
#     kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"),
#                   font_size = 10) %>%
#     scroll_box(width = "100%")
```


We plotted the average across time for each of the biomarkers that were nominally statistically significant, and indicated specific features responsible for the positive test result by listing the associated model parameters with $p<0.05$.

```{r plot4_oneway, eval = T, results='asis'}
require(stringr, quietly = T)
siggroups <- sapply(str_split(shortlist$parameter, ":"), function(x) x[1])
for(ii in 1:nrow(shortlist)){
    this_group <-siggroups[ii]
    this_bcell <- as.character(shortlist$biomarker[ii])
    cat("  \n###", as.character(shortlist$biomarker[ii]), "\n")
    
    sumtable <- suppressMessages(summary(models.b[[this_group]]$model[[this_bcell]]$model))
    sumtable <- as.data.frame(sumtable$coefficients)[-1, ,drop=F] # drop intercept
    if(!("Pr(>|t|)" %in% colnames(sumtable))) next()
    sigsum <- sumtable[sumtable[,"Pr(>|t|)"] <= 0.05, , drop = F]
    
    print(kable(sigsum[order(sigsum[,"Pr(>|t|)"]),,drop=F], row.names = T) %>%
              kable_styling(bootstrap_options = c("striped", 
                                                  "hover", 
                                                  "condensed",
                                                  "responsive"),
                            font_size = 12)
    )
    cat("  \n")
    
    suppressWarnings(print(plots.ts[[shortlist$biomarker[ii]]][[which(groups == this_group)]]))
    cat("  \n")
}

```



## Linear mixed-effect model {.tabset .tabset-fade .tabset-pills}

Next, we analyzed the association of patient categories with mean biomarker levels over time using a linear mixed effect model, with time as a continuous variable. This model assumes biomarker levels vary linearly with time. We reported all effects that achieved nominal statistical significance ($p<0.05$), while also indicating the Benjamini-Hochberg q-value. 

```{r bcell_models_lme, eval = T}
suppressMessages(require(lmerTest, quietly = TRUE))
suppressMessages(require(car, quietly = TRUE))
require(reshape2, quietly = TRUE)

df.lmer <- df.HMII
names(df.lmer) <- make.names(names(df.lmer), unique = TRUE)

groupvars.ix <- c(4,5,6,8,9,10,13)
groupvars <- names(df.lmer)[groupvars.ix]

bcells.ix <- c(bcellcyto)
bcells <- names(df.lmer)[bcells.ix]

models.b <- mclapply(groupvars, function(this_groupvar){
    models.bcells <- lapply(bcells, function(this_bcell){
        this_formula <- as.formula(paste0(this_bcell, " ~ ", this_groupvar, 
                                          " * Time + (1|PatientID)"))
        suppressMessages(suppressWarnings(this_model <- lmer(this_formula, data = droplevels(df.lmer))))
        this_anova <- Anova(this_model, type = 2)
        this_pvalues <- this_anova$`Pr(>Chisq)`
        names(this_pvalues) <- rownames(this_anova)
        #return(this_pvalues)
        return(list(model = this_model,
                    pvals = this_pvalues))
    })
    names(models.bcells) <- colnames(df)[bcellcyto]
    pvalues <- do.call(rbind, lapply(models.bcells, function(x) x$pvals))
    rownames(pvalues) <- bcells
    #return(pvalues)
    return(list(model = models.bcells,
                pvals = pvalues))
}, mc.cores = detectCores()-1)
names(models.b) <- groupvars
pvals <- lapply(models.b, function(x) x$pvals)
# something wrong here
names(pvals) <- groupvars
pvals.matrix <- do.call(cbind, lapply(pvals, function(this_pval) this_pval[,c(1,3)]))



# Benjamini Hochberg
# qBH <- matrix(p.adjust(as.numeric(pvals.matrix), 
#                        method = "BH"), 
#               nrow = nrow(pvals.matrix), 
#               ncol = ncol(pvals.matrix), 
#               byrow = F) 
# rownames(qBH) <- rownames(pvals.matrix)
# colnames(qBH) <- colnames(pvals.matrix)
# rownames(qBH) <- names(df)[bcells.ix]
# qvalsBH.df <- melt(qBH)
# colnames(qvalsBH.df) <- c("biomarker", "parameter", "qvalue")
# qvalsBH.df.ranked <- qvalsBH.df[order(qvalsBH.df$qvalue, decreasing = F),]
# qvalsBH.df.ranked[qvalsBH.df.ranked$qvalue <= 0.3,]

# Local FDR
require(fdrtool, quietly = T)
invisible(suppressMessages(fdrobj <- fdrtool(as.numeric(pvals.matrix), statistic = "pvalue", plot = F, verbose = F)))
qvals.matrix <- matrix(fdrobj$q, nrow = nrow(pvals.matrix), ncol = ncol(pvals.matrix), byrow = F)
rownames(qvals.matrix) <- rownames(pvals.matrix)
colnames(qvals.matrix) <- colnames(pvals.matrix)
rownames(qvals.matrix) <- names(df)[bcells.ix]

pvals.df <- melt(pvals.matrix)
qvals.df <- melt(qvals.matrix)
colnames(qvals.df) <- colnames(pvals.df) <- c("biomarker", "parameter", "qvalue")
qvals.df.short <- qvals.df[pvals.df$qvalue <= 0.05,]
shortlist <- qvals.df.short[order(qvals.df.short$qvalue),]
rownames(shortlist) <- 1:nrow(shortlist)

shortlist$time_cluster <- cluster[match(shortlist$biomarker, names(cluster))]
shortlist$bi_cluster <- bicluster$biomarkers[match(shortlist$biomarker, names(bicluster$biomarkers))]
shortlist$bi_cluster_optimal <- bicluster$biomarkers_optimal[match(shortlist$biomarker, names(bicluster$biomarkers_optimal))]
shortlist$qvalue <- signif(shortlist$qvalue, 3)
shortlist %>%
    mutate(
        #`biomarker` = row.names(.),
        qvalue = cell_spec(qvalue, color = ifelse(shortlist$qvalue > 0.05, "grey", "red"))
    ) %>% 
    kable(digits = 3, escape = F, row.names = T) %>%
    kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                  font_size = 10) %>%
    scroll_box(width = "100%")

this_table <- table(category = shortlist$parameter, cluster = shortlist$time_cluster)
kable(this_table) %>% 
    kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                  font_size = 10) %>%
    scroll_box(width = "100%")

fisher.test(this_table, simulate.p.value = T)

# kable(shortlist, 
#       digits = 3,
#       row.names = T,
#       caption = "Significant results") %>%
#     kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"),
#                   font_size = 10) %>%
#     scroll_box(width = "100%")
```




We plotted the average across time for each of the biomarkers that were nominally statistically significant, and indicated specific features responsible for the positive test result by listing the associated model parameters with $p<0.05$.


```{r plot4_lme, eval = T, results='asis'}
require(stringr, quietly = T)
siggroups <- sapply(str_split(shortlist$parameter, ":"), function(x) x[1])
for(ii in 1:nrow(shortlist)){
    this_group <-siggroups[ii]
    this_bcell <- as.character(shortlist$biomarker[ii])
    cat("  \n###", as.character(shortlist$biomarker[ii]), "\n")
    
    sumtable <- suppressMessages(summary(models.b[[this_group]]$model[[this_bcell]]$model))
    sumtable <- as.data.frame(sumtable$coefficients)[-1, ,drop=F] # drop intercept
    if(!("Pr(>|t|)" %in% colnames(sumtable))) next()
    sigsum <- sumtable[sumtable[,"Pr(>|t|)"] <= 0.05, , drop = F]
    
    print(kable(sigsum[order(sigsum[,"Pr(>|t|)"]),,drop=F], row.names = T) %>%
              kable_styling(bootstrap_options = c("striped", 
                                                  "hover", 
                                                  "condensed",
                                                  "responsive"),
                            font_size = 12)
    )
    cat("  \n")
    
    suppressWarnings(print(plots.ts[[shortlist$biomarker[ii]]][[which(groups == this_group)]]))
    cat("  \n")
}

```


## Two-way repeated measures anova {.tabset .tabset-fade .tabset-pills}

Finally, we analyzed the association of patient categories with mean biomarker levels over time using two-way repeated measures anova, with time as a categorical variable. This model assumes no temporal ordering, and is therefore better when modeling data with a more complicated time dynamic. We reported all effects that achieved nominal statistical significance ($p<0.05$), while also indicating the Benjamini-Hochberg q-value. 


```{r bcell_models_twoway, eval = T}
suppressMessages(require(lmerTest, quietly = TRUE))
suppressMessages(require(car, quietly = TRUE))
require(reshape2, quietly = TRUE)

df.lmer <- df.HMII
names(df.lmer) <- make.names(names(df.lmer), unique = TRUE)

groupvars.ix <- c(4,5,6,8,9,10,13)
groupvars <- names(df.lmer)[groupvars.ix]

bcells.ix <- c(bcellcyto)
bcells <- names(df.lmer)[bcells.ix]

models.b <- mclapply(groupvars, function(this_groupvar){
    models.bcells <- lapply(bcells, function(this_bcell){
        this_formula <- as.formula(paste0(this_bcell, " ~ ", this_groupvar, 
                                          " * factor(Time) + (1|PatientID)"))
        suppressMessages(suppressWarnings(this_model <- lmer(this_formula, data = droplevels(df.lmer))))
        this_anova <- Anova(this_model, type = 2)
        this_pvalues <- this_anova$`Pr(>Chisq)`
        names(this_pvalues) <- rownames(this_anova)
        #return(this_pvalues)
        return(list(model = this_model,
                    pvals = this_pvalues))
    })
    names(models.bcells) <- colnames(df)[bcellcyto]
    pvalues <- do.call(rbind, lapply(models.bcells, function(x) x$pvals))
    rownames(pvalues) <- bcells
    #return(pvalues)
    return(list(model = models.bcells,
                pvals = pvalues))
}, mc.cores = detectCores()-1)
names(models.b) <- groupvars
pvals <- lapply(models.b, function(x) x$pvals)
# something wrong here
names(pvals) <- groupvars
pvals.matrix <- do.call(cbind, lapply(pvals, function(this_pval) this_pval[,c(1,3)]))



# Benjamini Hochberg
# qBH <- matrix(p.adjust(as.numeric(pvals.matrix), 
#                        method = "BH"), 
#               nrow = nrow(pvals.matrix), 
#               ncol = ncol(pvals.matrix), 
#               byrow = F) 
# rownames(qBH) <- rownames(pvals.matrix)
# colnames(qBH) <- colnames(pvals.matrix)
# rownames(qBH) <- names(df)[bcells.ix]
# qvalsBH.df <- melt(qBH)
# colnames(qvalsBH.df) <- c("biomarker", "parameter", "qvalue")
# qvalsBH.df.ranked <- qvalsBH.df[order(qvalsBH.df$qvalue, decreasing = F),]
# qvalsBH.df.ranked[qvalsBH.df.ranked$qvalue <= 0.3,]

# Local FDR
require(fdrtool, quietly = T)
invisible(suppressMessages(fdrobj <- fdrtool(as.numeric(pvals.matrix), statistic = "pvalue", plot = F, verbose = F)))
qvals.matrix <- matrix(fdrobj$q, nrow = nrow(pvals.matrix), ncol = ncol(pvals.matrix), byrow = F)
rownames(qvals.matrix) <- rownames(pvals.matrix)
colnames(qvals.matrix) <- colnames(pvals.matrix)
rownames(qvals.matrix) <- names(df)[bcells.ix]

pvals.df <- melt(pvals.matrix)
qvals.df <- melt(qvals.matrix)
colnames(qvals.df) <- colnames(pvals.df) <- c("biomarker", "parameter", "qvalue")
qvals.df.short <- qvals.df[pvals.df$qvalue <= 0.05,]
shortlist <- qvals.df.short[order(qvals.df.short$qvalue),]
rownames(shortlist) <- 1:nrow(shortlist)

shortlist$time_cluster <- cluster[match(shortlist$biomarker, names(cluster))]
shortlist$bi_cluster <- bicluster$biomarkers[match(shortlist$biomarker, names(bicluster$biomarkers))]
shortlist$bi_cluster_optimal <- bicluster$biomarkers_optimal[match(shortlist$biomarker, names(bicluster$biomarkers_optimal))]
shortlist$qvalue <- signif(shortlist$qvalue, 3)
shortlist %>%
    mutate(
        #`biomarker` = row.names(.),
        qvalue = cell_spec(qvalue, color = ifelse(shortlist$qvalue > 0.05, "grey", "red"))
    ) %>% 
    kable(digits = 3, escape = F, row.names = T) %>%
    kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                  font_size = 10) %>%
    scroll_box(width = "100%")

this_table <- table(category = shortlist$parameter, cluster = shortlist$time_cluster)
kable(this_table) %>% 
    kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                  font_size = 10) %>%
    scroll_box(width = "100%")

fisher.test(this_table, simulate.p.value = T)

# kable(shortlist, 
#       digits = 3,
#       row.names = T,
#       caption = "Significant results") %>%
#     kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"),
#                   font_size = 10) %>%
#     scroll_box(width = "100%")
```



We plotted the average across time for each of the biomarkers that were nominally statistically significant, and indicated specific features responsible for the positive test result by listing the associated model parameters with $p<0.05$.

```{r plot4_twoway, eval = T, results='asis'}
require(stringr, quietly = T)
siggroups <- sapply(str_split(shortlist$parameter, ":"), function(x) x[1])
for(ii in 1:nrow(shortlist)){
    this_group <-siggroups[ii]
    this_bcell <- as.character(shortlist$biomarker[ii])
    cat("  \n###", as.character(shortlist$biomarker[ii]), "\n")
    
    sumtable <- suppressMessages(summary(models.b[[this_group]]$model[[this_bcell]]$model))
    sumtable <- as.data.frame(sumtable$coefficients)[-1, ,drop=F] # drop intercept
    if(!("Pr(>|t|)" %in% colnames(sumtable))) next()
    sigsum <- sumtable[sumtable[,"Pr(>|t|)"] <= 0.05, , drop = F]
    
    print(kable(sigsum[order(sigsum[,"Pr(>|t|)"]),,drop=F], row.names = T) %>%
              kable_styling(bootstrap_options = c("striped", 
                                                  "hover", 
                                                  "condensed",
                                                  "responsive"),
                            font_size = 12)
    )
    cat("  \n")
    
    suppressWarnings(print(plots.ts[[shortlist$biomarker[ii]]][[which(groups == this_group)]]))
    cat("  \n")
}

```






# All MCS devices

## Categorical associations {.tabset .tabset-fade .tabset-pills}

We analyzed the categorical variables for pairwise correlations using Fisher's exact test.


### Survival

We computed odds ratios associated with survival.

```{r survival_metadata_1, message=FALSE}
df.factors <- df[match(levels(df$PatientID), df$PatientID),]
isfactor <- which(sapply(df.factors, is.factor))[-1]
contingency <- lapply(isfactor[!(names(isfactor) %in% c("Survival","Outcome", "LowIntermacs"))], 
                      function(this_factor){
                          table(df.factors[,this_factor], df.factors$Survival)
                      })

fisher.p <- sapply(contingency, function(this_table){
    ft <- fisher.test(this_table)
    ft$p
})

fisher.OR.0 <- lapply(contingency, function(this_table){
    ft <- fisher.test(this_table)
    if(is.null(ft$estimate)) {
        ft$estimate <- NA
        ft$conf.int <- c(NA,NA)
    }
    ret <- list(OR = ft$estimate, lowerCL = ft$conf.int[1], upperCL = ft$conf.int[2])
    return(ret)
})
fisher.OR <- as.data.frame(do.call(rbind, fisher.OR.0))
fisher.OR$pvalue <- fisher.p
fisher.OR$qvalue <- p.adjust(fisher.p, method = "BH")
fisher.all <- as.data.frame(sapply(fisher.OR, as.numeric))
rownames(fisher.all) <- rownames(fisher.OR)

qtable <- signif(fisher.all[order(fisher.all$pvalue),],3)

qtable %>%
    mutate(
        `Factor` = row.names(.),
        pvalue = cell_spec(pvalue, color = ifelse(qtable$pvalue > 0.05, "grey", "red")),
        qvalue = cell_spec(qvalue, color = ifelse(qtable$qvalue > 0.05, "grey", "red"))
    ) %>% 
    kable(escape = F, row.names = T) %>%
    kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                  font_size = 12)
```

### InterMACS

We computed odds ratios associated with the InterMACS score.

```{r intermacsbin_metadata, message=FALSE}
isfactor <- which(sapply(df, is.factor))[-1]
contingency <- lapply(isfactor[!(names(isfactor) %in% c("LowIntermacs", "InterMACS"))], 
                      function(this_factor){
                          table(df.factors[,this_factor], df.factors$LowIntermacs)
                      })

fisher.p <- sapply(contingency, function(this_table){
    ft <- fisher.test(this_table, simulate.p.value = F, B = 10000)
    ft$p
})

fisher.OR.0 <- lapply(contingency, function(this_table){
    ft <- fisher.test(this_table, simulate.p.value = F, B = 10000)
    if(is.null(ft$estimate)) {
        ft$estimate <- NA
        ft$conf.int <- c(NA,NA)
    }
    ret <- list(OR = ft$estimate, lowerCL = ft$conf.int[1], upperCL = ft$conf.int[2])
    return(ret)
})
fisher.OR <- as.data.frame(do.call(rbind, fisher.OR.0))
fisher.OR$pvalue <- fisher.p
fisher.OR$qvalue <- p.adjust(fisher.p, method = "BH")
fisher.all <- as.data.frame(sapply(fisher.OR, as.numeric))
rownames(fisher.all) <- rownames(fisher.OR)

qtable <- signif(fisher.all[order(fisher.all$pvalue),],3)

qtable %>%
    mutate(
        `Factor` = row.names(.),
        pvalue = cell_spec(pvalue, color = ifelse(qtable$pvalue > 0.05, "grey", "red")),
        qvalue = cell_spec(qvalue, color = ifelse(qtable$qvalue > 0.05, "grey", "red"))
    ) %>% 
    kable(escape = F, row.names = T) %>%
    kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                  font_size = 12)
```


### Sensitization

We computed odds ratios associated with sensitization.

```{r sensitization_metadata, message=FALSE}
isfactor <- which(sapply(df, is.factor))[-1]
contingency <- lapply(isfactor[!(names(isfactor) %in% c("Sensitized"))], 
                      function(this_factor){
                          table(df.factors[,this_factor], df.factors$Sensitized)
                      })

fisher.p <- sapply(contingency, function(this_table){
    ft <- fisher.test(this_table)
    ft$p
})

fisher.OR.0 <- lapply(contingency, function(this_table){
    ft <- fisher.test(this_table)
    if(is.null(ft$estimate)) {
        ft$estimate <- NA
        ft$conf.int <- c(NA,NA)
    }
    ret <- list(OR = ft$estimate, lowerCL = ft$conf.int[1], upperCL = ft$conf.int[2])
    return(ret)
})
fisher.OR <- as.data.frame(do.call(rbind, fisher.OR.0))
fisher.OR$pvalue <- fisher.p
fisher.OR$qvalue <- p.adjust(fisher.p, method = "BH")
fisher.all <- as.data.frame(sapply(fisher.OR, as.numeric))
rownames(fisher.all) <- rownames(fisher.OR)

qtable <- signif(fisher.all[order(fisher.all$pvalue),],3)

qtable %>%
    mutate(
        `Factor` = row.names(.),
        pvalue = cell_spec(pvalue, color = ifelse(qtable$pvalue > 0.05, "grey", "red")),
        qvalue = cell_spec(qvalue, color = ifelse(qtable$qvalue > 0.05, "grey", "red"))
    ) %>% 
    kable(escape = F, row.names = T) %>%
    kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                  font_size = 12)
```




### Sex

We computed odds ratios associated with sex.

```{r sex_metadata, message=FALSE}
isfactor <- which(sapply(df, is.factor))[-1]
contingency <- lapply(isfactor[!(names(isfactor) %in% c("Sex"))], 
                      function(this_factor){
                          table(df.factors[,this_factor], df.factors$Sex)
                      })

fisher.p <- sapply(contingency, function(this_table){
    ft <- fisher.test(this_table, simulate.p.value = F, B = 10000)
    ft$p
})

fisher.OR.0 <- lapply(contingency, function(this_table){
    ft <- fisher.test(this_table, simulate.p.value = F, B = 10000)
    if(is.null(ft$estimate)) {
        ft$estimate <- NA
        ft$conf.int <- c(NA,NA)
    }
    ret <- list(OR = ft$estimate, lowerCL = ft$conf.int[1], upperCL = ft$conf.int[2])
    return(ret)
})
fisher.OR <- as.data.frame(do.call(rbind, fisher.OR.0))
fisher.OR$pvalue <- fisher.p
fisher.OR$qvalue <- p.adjust(fisher.p, method = "BH")
fisher.all <- as.data.frame(sapply(fisher.OR, as.numeric))
rownames(fisher.all) <- rownames(fisher.OR)

qtable <- signif(fisher.all[order(fisher.all$pvalue),],3)

qtable %>%
    mutate(
        `Factor` = row.names(.),
        pvalue = cell_spec(pvalue, color = ifelse(qtable$pvalue > 0.05, "grey", "red")),
        qvalue = cell_spec(qvalue, color = ifelse(qtable$qvalue > 0.05, "grey", "red"))
    ) %>% 
    kable(escape = F, row.names = T) %>%
    kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                  font_size = 12)
```

### Age

We computed odds ratios associated with age.

```{r age_metadata, message=FALSE}
isfactor <- which(sapply(df, is.factor))[-1]
contingency <- lapply(isfactor[!(names(isfactor) %in% c("AgeGreater60"))], 
                      function(this_factor){
                          table(df.factors[,this_factor], df.factors$AgeGreater60)
                      })

fisher.p <- sapply(contingency, function(this_table){
    ft <- fisher.test(this_table, simulate.p.value = F, B = 10000)
    ft$p
})

fisher.OR.0 <- lapply(contingency, function(this_table){
    ft <- fisher.test(this_table, simulate.p.value = F, B = 10000)
    if(is.null(ft$estimate)) {
        ft$estimate <- NA
        ft$conf.int <- c(NA,NA)
    }
    ret <- list(OR = ft$estimate, lowerCL = ft$conf.int[1], upperCL = ft$conf.int[2])
    return(ret)
})
fisher.OR <- as.data.frame(do.call(rbind, fisher.OR.0))
fisher.OR$pvalue <- fisher.p
fisher.OR$qvalue <- p.adjust(fisher.p, method = "BH")
fisher.all <- as.data.frame(sapply(fisher.OR, as.numeric))
rownames(fisher.all) <- rownames(fisher.OR)

qtable <- signif(fisher.all[order(fisher.all$pvalue),],3)

qtable %>%
    mutate(
        `Factor` = row.names(.),
        pvalue = cell_spec(pvalue, color = ifelse(qtable$pvalue > 0.05, "grey", "red")),
        qvalue = cell_spec(qvalue, color = ifelse(qtable$qvalue > 0.05, "grey", "red"))
    ) %>% 
    kable(escape = F, row.names = T) %>%
    kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                  font_size = 12)
```

### VAD Indication

We computed odds ratios associated with VAD Indication.

```{r vad_metadata, message=FALSE}
isfactor <- which(sapply(df, is.factor))[-1]
contingency <- lapply(isfactor[!(names(isfactor) %in% c("VAD Indication"))], 
                      function(this_factor){
                          table(df.factors[,this_factor], df.factors$`VAD Indication`)
                      })

fisher.p <- sapply(contingency, function(this_table){
    ft <- fisher.test(this_table, simulate.p.value = F, B = 10000)
    ft$p
})

fisher.OR.0 <- lapply(contingency, function(this_table){
    ft <- fisher.test(this_table, simulate.p.value = F, B = 10000)
    if(is.null(ft$estimate)) {
        ft$estimate <- NA
        ft$conf.int <- c(NA,NA)
    }
    ret <- list(OR = ft$estimate, lowerCL = ft$conf.int[1], upperCL = ft$conf.int[2])
    return(ret)
})
fisher.OR <- as.data.frame(do.call(rbind, fisher.OR.0))
fisher.OR$pvalue <- fisher.p
fisher.OR$qvalue <- p.adjust(fisher.p, method = "BH")
fisher.all <- as.data.frame(sapply(fisher.OR, as.numeric))
rownames(fisher.all) <- rownames(fisher.OR)

qtable <- signif(fisher.all[order(fisher.all$pvalue),],3)

qtable %>%
    mutate(
        `Factor` = row.names(.),
        pvalue = cell_spec(pvalue, color = ifelse(qtable$pvalue > 0.05, "grey", "red")),
        qvalue = cell_spec(qvalue, color = ifelse(qtable$qvalue > 0.05, "grey", "red"))
    ) %>% 
    kable(escape = F, row.names = T) %>%
    kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                  font_size = 12)
```


### RVAD

We computed odds ratios associated with RVAD.

```{r rvad_metadata, message=FALSE}
isfactor <- which(sapply(df, is.factor))[-1]
contingency <- lapply(isfactor[!(names(isfactor) %in% c("RVAD"))], 
                      function(this_factor){
                          table(df.factors[,this_factor], df.factors$RVAD)
                      })

fisher.p <- sapply(contingency, function(this_table){
    ft <- fisher.test(this_table)
    ft$p
})

fisher.OR.0 <- lapply(contingency, function(this_table){
    ft <- fisher.test(this_table)
    if(is.null(ft$estimate)) {
        ft$estimate <- NA
        ft$conf.int <- c(NA,NA)
    }
    ret <- list(OR = ft$estimate, lowerCL = ft$conf.int[1], upperCL = ft$conf.int[2])
    return(ret)
})
fisher.OR <- as.data.frame(do.call(rbind, fisher.OR.0))
fisher.OR$pvalue <- fisher.p
fisher.OR$qvalue <- p.adjust(fisher.p, method = "BH")
fisher.all <- as.data.frame(sapply(fisher.OR, as.numeric))
rownames(fisher.all) <- rownames(fisher.OR)

qtable <- signif(fisher.all[order(fisher.all$pvalue),],3)

qtable %>%
    mutate(
        `Factor` = row.names(.),
        pvalue = cell_spec(pvalue, color = ifelse(qtable$pvalue > 0.05, "grey", "red")),
        qvalue = cell_spec(qvalue, color = ifelse(qtable$qvalue > 0.05, "grey", "red"))
    ) %>% 
    kable(escape = F, row.names = T) %>%
    kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                  font_size = 12)
```


### Device-type

We computed odds ratios associated with Device Type.

```{r device_metadata, message=FALSE}
isfactor <- which(sapply(df, is.factor))[-1]
contingency <- lapply(isfactor[!(names(isfactor) %in% c("Device Type"))], 
                      function(this_factor){
                          table(df.factors[,this_factor], df.factors$`Device Type`)
                      })

fisher.p <- sapply(contingency, function(this_table){
    ft <- fisher.test(this_table, simulate.p.value = T, B = 10000)
    ft$p
})

fisher.OR.0 <- lapply(contingency, function(this_table){
    ft <- fisher.test(this_table, simulate.p.value = T, B = 10000)
    if(is.null(ft$estimate)) {
        ft$estimate <- NA
        ft$conf.int <- c(NA,NA)
    }
    ret <- list(OR = ft$estimate, lowerCL = ft$conf.int[1], upperCL = ft$conf.int[2])
    return(ret)
})
fisher.OR <- as.data.frame(do.call(rbind, fisher.OR.0))
fisher.OR$pvalue <- fisher.p
fisher.OR$qvalue <- p.adjust(fisher.p, method = "BH")
fisher.all <- as.data.frame(sapply(fisher.OR, as.numeric))
rownames(fisher.all) <- rownames(fisher.OR)

qtable <- signif(fisher.all[order(fisher.all$pvalue),],3)

qtable %>%
    mutate(
        `Factor` = row.names(.),
        pvalue = cell_spec(pvalue, color = ifelse(qtable$pvalue > 0.05, "grey", "red")),
        qvalue = cell_spec(qvalue, color = ifelse(qtable$qvalue > 0.05, "grey", "red"))
    ) %>% 
    kable(escape = F, row.names = T) %>%
    kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                  font_size = 12)
```


## Conditional distributions of categories

We used the `GGally` package to visualize conditional distributions for the categorical variables.

```{r ggpairs, fig.height=10, message=FALSE, warning=FALSE}
df.temp <- df.factors
colnames(df.temp) <- make.names(colnames(df), unique = T)
#invisible(
suppressWarnings(
    suppressMessages(
        suppressWarnings(ggpairs(df.temp, 
                #mapping = aes(color = Survival), 
                columns = colnames(df.temp)[c(3,5,6,7,8,9,10,11,12,13)]) +
            ggplot2::theme_grey(base_size = 7)
    )))
#)
```



## Identification of clusters

We double-standardized ( [Efron 2009](https://projecteuclid.org/euclid.aoas/1254773272)) the data and computed the correlation matrix for the biomarkers using all pairwise complete data. We then clustered the biomarkers using those correlations, and clustered the samples that remained after removing missing data. 

```{r sample_correlation_heatmap, message=F, fig.height=10}
require(pheatmap, quietly = T)
require(RColorBrewer, quietly = T)


colorfun <- function(nlevels, func = pal_d3, ...){
    if(nlevels > 10) return(standardColors(nlevels))
    if(nlevels <=10) return(func(...)(nlevels))
} 

annotation.row <- data.frame("biomarker" = factor(c(rep("B-cell",29), rep("cytokine",38))))
annotation.col <- df.raw[,c(1,4,5,6,7,8,9,10,11,12,13)]
annotation.colors <- lapply(colnames(annotation.col), function(nam){
    colrs <- colorfun(nlevels(annotation.col[[nam]]))
    names(colrs) <- levels(annotation.col[[nam]])
    return(colrs)
})
names(annotation.colors) <- colnames(annotation.col)
annotation.colors[["biomarker"]] <- colorfun(nlevels(annotation.row$biomarker))
names(annotation.colors[["biomarker"]]) <- levels(annotation.row$biomarker)

df.raw.ds <- df.raw
df.raw.ds[,bcellcyto] <- double_standardize(df.raw[,c(bcellcyto)])
df.patient <- t(na.omit(double_standardize((df.raw[,bcellcyto]))))
rownames(annotation.row) <- rownames(df.patient)

r.biomarker <- cor(df.raw.ds[,bcellcyto], use = "p")
tree <- hclust(as.dist((1-r.biomarker)/2), method = "ward.D2")
#pheatmap(t(df.raw.ds[,bcellcyto]), cluster_rows=tree, cutree_rows = 7, border_color = NA, cluster_cols = F)
p1 <- pheatmap(df.patient, clustering_method = "ward.D2", cluster_rows = tree, cutree_rows = 7, cutree_cols = 4, border_color = NA, silent = T)



# original
#p1 <- pheatmap(df.patient, clustering_method = "ward.D2", cutree.rows = 4, cutree_cols = 4, silent = TRUE)
bicluster <- list()
bicluster$biomarkers <- cutree(p1$tree_row, k=7)
bicluster$samples <- cutree(p1$tree_col, k=4)
annotation.row$cluster <- factor(bicluster$biomarkers)
annotation.colors$cluster <- colorfun(nlevels(annotation.row$cluster), func = pal_simpsons)
names(annotation.colors$cluster) <- levels(factor(annotation.row$cluster))
bicluster$annotation.colors <- annotation.colors$cluster

pheatmap(df.patient, 
         color = colorRampPalette(rev(brewer.pal(n = 10, name = "RdBu")))(100),
         breaks = c(seq(-max(abs(df.patient), na.rm=T), 0, length.out = 50), seq(0.001, max(abs(df.patient), na.rm=T), length.out = 50)),
         #scale = "row",
         clustering_distance_rows = "euclidean",
         clustering_distance_cols = "euclidean",
         fontsize = 7,
         cutree_rows = 7,
         cutree_cols = 7,
         cluster_cols = T,
         cluster_rows = tree,
         show_colnames = F,
         annotation_col = annotation.col,
         annotation_row = annotation.row,
         annotation_colors = annotation.colors,
         clustering_method = "ward.D2"
)
```


## Clusters over time  {.tabset .tabset-fade .tabset-pills}

```{r, warning=FALSE, message=FALSE}
df.raw.ds.long <- melt(df.raw.ds, id.vars = colnames(df)[1:13])

make_long_with_clusterID <- function(dataframe, form, cluster, func = function(x) mean(x, na.rm=T)){
    colnames(dataframe) <- make.names(colnames(dataframe))
    this_df <- aggregate(form, data = dataframe, FUN = func)
    this_df$cluster <- cluster[match(this_df$variable, names(cluster))]
    return(this_df)
}

stat_sum_df <- function(fun, geom="errorbar", ...) {
    stat_summary(fun.data = fun, geom = geom, width = 1, ...)
}

this_formula <- as.formula(paste0("value~variable*Time"))
this_df <- make_long_with_clusterID(df.raw.ds.long, 
                                        this_formula,
                                        bicluster$biomarkers)

g <- ggplot(this_df) + 
        aes(x=as.numeric(as.character(Time)), y=value, 
            color = factor(cluster), fill = factor(cluster), group = variable) + 
        #geom_point(alpha = 0.1, size = 1) + 
        #geom_line(alpha = 0.2) +
        xlab("Time (days)") +
        ylab("Standardized level (z-score)") +
        scale_x_continuous(breaks = unique(this_df$Time)) +
        #ggtitle(this_factor) +
        #stat_summary(fun.y = mean, aes(group = cluster), geom=c("line"), size = .02, position = position_dodge(.5)) +
        stat_smooth(method = "loess", aes(group = cluster), span = .5, size = 1, alpha = 0.0) +
        stat_summary(fun.y = mean, aes(group = cluster), geom=c("point"), position = position_dodge(.5)) +
        stat_sum_df(function(x) mean_cl_boot(x, conf.int = 0.68), mapping = aes(group = cluster), position = position_dodge(.5)) + 
        scale_color_simpsons(name = "Cluster") + scale_fill_simpsons(name = "Cluster") + 
        theme_classic() 
print(g)


g2 <- ggplot(this_df) + 
        aes(x=as.numeric(as.character(Time)), y=value, 
            color = factor(cluster), fill = factor(cluster), group = variable) + 
        #geom_point(alpha = 0.1, size = 1) + 
        #geom_line(alpha = 0.2) +
        xlab("Time (days)") +
        ylab("Standardized level (z-score)") +
        scale_x_continuous(breaks = unique(this_df$Time)) +
        #ggtitle(this_factor) +
        stat_summary(fun.y = mean, aes(group = cluster), geom=c("line"), size = .02, position = position_dodge(.5)) +
        stat_smooth(method = "loess", aes(group = cluster), span = .5, size = 1, alpha = 0.1) +
        stat_summary(fun.y = mean, aes(group = cluster), geom=c("point"), position = position_dodge(.5)) +
        stat_sum_df(function(x) mean_cl_boot(x, conf.int = 0.68), mapping = aes(group = cluster), position = position_dodge(.5)) + 
        scale_color_simpsons(name = "Cluster") + scale_fill_simpsons(name = "Cluster") + 
        theme_classic() 
print(g2)

g3 <- ggplot(this_df) + 
        aes(x=as.numeric(as.character(Time)), y=value, 
            color = factor(cluster), fill = factor(cluster), group = variable) + 
        geom_point(alpha = 0.1, size = 1) + 
        geom_line(alpha = 0.2) +
        xlab("Time (days)") +
        ylab("Standardized level (z-score)") +
        scale_x_continuous(breaks = unique(this_df$Time)) +
        #ggtitle(this_factor) +
        stat_summary(fun.y = mean, aes(group = cluster), geom=c("line"), size = .02, position = position_dodge(.5)) +
        stat_smooth(method = "loess", aes(group = cluster), span = .5, size = 1, alpha = 0.1) +
        stat_summary(fun.y = mean, aes(group = cluster), geom=c("point"), position = position_dodge(.5)) +
        stat_sum_df(function(x) mean_cl_boot(x, conf.int = 0.68), mapping = aes(group = cluster), position = position_dodge(.5)) + 
        scale_color_simpsons(name = "Cluster") + scale_fill_simpsons(name = "Cluster") + 
        theme_classic() 
print(g3)

```


We analyzed the difference between categories for each cluster, using a paired t-test at each timepoint to pick out interesting differences. We label the biomarkers for tests that have Benjamini-Hochberg $q<0.05$.


```{r, results='asis', warning=F, message=F, fig.height=20}
require(ggrepel, quietly = TRUE)

presult <- list()
for(this_factor in groups){
    this_formula <- as.formula(paste0("value~variable*Time*", make.names(this_factor)))
    this_df <- make_long_with_clusterID(df.raw.ds.long, 
                                        this_formula,
                                        bicluster$biomarkers)
    this_df$name <- as.character(this_df$variable )
    
    # compute t-tests
    presult[[this_factor]] <- lapply(split(this_df, this_df$cluster), function(x){
        lapply(split(x, as.factor(x$Time)), function(y){
            n <- table(y[[make.names(this_factor)]])
            if(all(n > 1) & length(n)==2){
                res <- t.test(as.formula(paste0("value ~ ", make.names(this_factor))), paired = TRUE, data = y)
                t <- res$statistic
                p <- res$p.value
            } else {
                t <- 0
                p <- 1
            }
           return(p)
        })  
    }) 
}

#hist(unlist(presult))
q <- p.adjust(unlist(presult), method = "BH")
q_factor <- sapply(str_split(names(q), "[.]"), function(x) x[1])
q_clusters <- sapply(str_split(names(q), "[.]"), function(x) x[2])
q_time <- sapply(str_split(names(q), "[.]"), function(x) x[3])
these_qvals <- data.frame(qval = q, factor = q_factor, cluster = q_clusters, Time = q_time)

for(this_factor in groups){
    this_formula <- as.formula(paste0("value~variable*Time*", make.names(this_factor)))
    this_df <- make_long_with_clusterID(df.raw.ds.long,
                                        this_formula,
                                        bicluster$biomarkers)
    this_df$name <- as.character(this_df$variable )
    # 
    # # compute t-tests
    # presult <- lapply(split(this_df, this_df$cluster), function(x){
    #     lapply(split(x, as.factor(x$Time)), function(y){
    #         n <- table(y[[make.names(this_factor)]])
    #         if(all(n > 1) & length(n)==2){
    #             res <- t.test(as.formula(paste0("value ~ ", make.names(this_factor))), paired = TRUE, data = y)
    #             t <- res$statistic
    #             p <- res$p.value
    #         } else {
    #             t <- 0
    #             p <- 1
    #         }
    #        return(p)
    #     })  
    # }) 
    # 
    # require(stringr, quietly = T)
    # q <- p.adjust(unlist(presult), method = "BH")
    # q_clusters <- sapply(str_split(names(q), "[.]"), function(x) x[1])
    # q_time <- sapply(str_split(names(q), "[.]"), function(x) x[2])
    # these_qvals <- data.frame(qval = q, cluster = q_clusters, Time = q_time)
    
    # label only significant differences
    for(this_cluster in levels(factor(this_df$cluster))){
        # this_pvals <- presult[[this_cluster]]
        # this_qvals <- p.adjust(this_pvals, method = "bonferroni")
        #pos <- this_qvals < 0.05
        for(this_time in levels(factor(this_df$Time))){
            this_qval <- these_qvals$qval[these_qvals$factor == this_factor & these_qvals$cluster == this_cluster & these_qvals$Time == this_time]
            #this_qval <- these_qvals[[this_factor]]$qval[these_qvals$cluster == this_cluster & these_qvals$Time == this_time]
            #ii <- which(names(this_qvals) == this_time)
            if(length(this_qval) > 0){
                if(this_qval < 0.05){
                    this_df$name[this_df$cluster == this_cluster & this_df$Time == this_time & this_df[[this_factor]] == levels(this_df[[this_factor]])[1]] <- ""
                } else {
                    this_df$name[this_df$cluster == this_cluster & this_df$Time == this_time] <- ""
                }
            } else {
                next()
            }
        }
    }
    
    g <- ggplot(this_df) + 
        aes(x=as.numeric(as.character(Time)), y=value, 
            color = factor(cluster), fill = factor(cluster), label = name) + 
        aes_string(group = paste("interaction(variable,", make.names(this_factor), ")"), lty = make.names(this_factor)) +
        geom_point(alpha = 0.1, size = 1) + 
        geom_line(alpha = 0.2) +
        xlab("Time (days)") +
        ylab("Standardized level (z-score)") +
        scale_x_continuous(breaks = unique(this_df$Time)) +
        ggtitle(this_factor) +
        #stat_smooth(method = "loess", aes_string(group = make.names(this_factor)), span = .6, alpha = 0.3) +
        stat_summary(fun.y = mean, aes_string(group = make.names(this_factor)), geom=c("line"), size = .02, position = position_dodge(.5)) +
        stat_smooth(method = "loess", aes_string(group = make.names(this_factor)), span = .6, size = 1, alpha = 0.3) +
        stat_summary(fun.y = mean, aes_string(group = make.names(this_factor)), geom=c("point"), position = position_dodge(.5)) +
        stat_sum_df(function(x) mean_cl_boot(x, conf.int = 0.68), mapping = aes_string(group = make.names(this_factor)), position = position_dodge(.5)) + 
        scale_color_simpsons(name = "Cluster") + scale_fill_simpsons(name = "Cluster") + 
        geom_text_repel(aes(as.numeric(as.character(Time)), value), 
                         size = 1.5, 
                         fontface = 'bold', 
                         color = 'black',
                         segment.alpha = 0.2,
                         alpha = 1) +
        theme_classic() +
        facet_grid(cluster~., scales = "free")
    
    
    
     cat("  \n###", this_factor, "\n")
    
    print(g)
    
    cat("  \n")
}


```



# Variability of MCS devices 

## PCA {.tabset .tabset-fade .tabset-pills}

We observed large variability between device types, compared to the variability within device types. 

```{r PCA_full, eval = T, results='asis'}
suppressMessages(require(ggbiplot, quietly = T))
require(ggsci, quietly = T)

isna <- unique(unlist(apply(df[,c(bcellcyto)], 2, function(x) which(is.na(x)))))
pca <- prcomp(double_standardize(df[-isna, c(bcellcyto)]), center = TRUE, scale. = TRUE)

colorfun <- function(grouping, ...){
    if(nlevels(factor(grouping)) > 10) scale_color_discrete(...)
    if(nlevels(factor(grouping)) <=10) scale_color_d3(...)
} 

plotvars <- names(df)[c(11,1:13)]
plots.pca <- mclapply(plotvars, function(this_var){
    this_groups <- df[-isna, this_var]
    if(is.numeric(this_groups)) this_groups <- cut(this_groups, 4)
    
    ggbiplot(pca,
             groups = this_groups,
             ellipse = TRUE,
             alpha = 0.3,
             varname.size = 1.2) + 
        colorfun(this_groups, name = this_var) +
        ggtitle(paste0(this_var, " variability")) +
        theme_classic() 
}, mc.cores = detectCores()-1)
names(plots.pca) <- plotvars
#plots.pca$PatientID
#plots.pca$`Device Type`

for(ii in 1:length(plots.pca)){
    cat("  \n###", names(plots.pca)[ii], "\n")
    suppressWarnings(print(plots.pca[[ii]]))
    cat("  \n")
}

require(factoextra, quietly = T)
fviz_screeplot(pca, ncp = 20)

# Contributions of variables to PC1
fviz_contrib(pca, choice = "var", axes = 1, top = 30, sort.val = "asc") + coord_flip()
# Contributions of variables to PC2
fviz_contrib(pca, choice = "var", axes = 2, top = 30, sort.val = "asc") + coord_flip()
# Contributions of variables to PC3
fviz_contrib(pca, choice = "var", axes = 3, top = 30, sort.val = "asc") + coord_flip()
# Contributions of variables to PC4
fviz_contrib(pca, choice = "var", axes = 4, top = 30, sort.val = "asc") + coord_flip()
```



## Fisher's exact test {.tabset .tabset-fade .tabset-pills}

We analyzed the associations between device types and patient categories using Fisher's exact test. 

```{r Fisher_test_device, results="asis"}
isfactor <- which(sapply(df, is.factor))[-1]
contingency <- lapply(isfactor[names(isfactor) != "Device Type"], 
                      function(this_factor){
                          table(df.factors[,this_factor], df.factors$`Device Type`)
                      })

fisher.p <- sapply(contingency, function(this_table){
    fisher.test(this_table, simulate.p.value = T, B = 10000)$p
})
fisher.q <- p.adjust(fisher.p, method = "BH")

signif.ix <- which(fisher.p < 0.05)
signif.order <- sort(fisher.q[signif.ix], index.return = T)$ix
for(this_ix in signif.ix[signif.order]){
    cat("  \n###", names(contingency)[this_ix], "\n")
    cat(paste0("Benjamini-Hochberg qvalue = ", signif(fisher.q[this_ix], 2)),
        ". \n")
    print(kable(contingency[this_ix][[1]],  row.names = T) %>%
              kable_styling(bootstrap_options = c("striped", 
                                                  "hover", 
                                                  "condensed",
                                                  "responsive"),
                            font_size = 12)
    )
    cat("  \n")
}
```


## One-way repeated measures anova {.tabset .tabset-fade .tabset-pills}

We first analyzed the association of mean biomarker levels with device type using a one-way repeated measures anova. This model assumes there are no temporal effects (we will include those later). We reported all biomarkers that had a nominally statistically significant association ($p<0.05$), while also indicating the Benjamini-Hochberg q-value.


```{r device_means, eval = T}
suppressMessages(require(lmerTest, quietly = T))
suppressMessages(require(car, quietly = TRUE))

df.device <- df
colnames(df.device) <- make.names(colnames(df), unique = T)

varnames <- colnames(df.device)[c(bcellcyto)]
models.device <- mclapply(varnames, function(this_var){
    this_formula <- as.formula(paste0(this_var, " ~ Device.Type + (1|PatientID)"))
    invisible(suppressMessages(this_model <- lmer(this_formula, data = df.device)))
    this_anova <- Anova(this_model, type = 2)
    pvals <- this_anova$`Pr(>Chisq)`[c(1)]
    return(list(model = this_model,
                pvals = pvals))
}, mc.cores = detectCores()-1)
names(models.device) <- colnames(df)[c(bcellcyto)]

pvals <- do.call(rbind, lapply(models.device, function(x) x$pvals))
rownames(pvals) <- colnames(df)[c(bcellcyto)]
colnames(pvals) <- c("pvalue")

qBH <- matrix(p.adjust(pvals, method = "BH"), nrow = nrow(pvals))
rownames(qBH) <- colnames(df)[c(bcellcyto)]
colnames(qBH) <- c("qvalue")

sigvars <- apply(apply(pvals, 2, function(x) x<=0.05), 1, function(x) sum(x) > 0)

sig.qtable <- cbind(pvals,qBH)[sigvars,,drop=F][order(apply(pvals[sigvars,,drop=F], 1, min)),,drop=F]

qtable <- as.data.frame(signif(sig.qtable, 2))
qtable %>%
    mutate(
        `biomarker` = row.names(.),
        pvalue = cell_spec(pvalue, color = ifelse(qtable$pvalue > 0.05, "grey", "red")),
        qvalue = cell_spec(qvalue, color = ifelse(qtable$qvalue > 0.05, "grey", "red"))
    ) %>%
    kable( escape = F,
           digits = 20,
           row.names = T,
           caption = "Significant device-type q-values") %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"),
                  font_size = 12) %>%
    scroll_box(width = "100%")
```



We plotted the average across time for each of the biomarkers that were nominally statistically significant, and indicated specific features responsible for the positive test result by listing the associated model parameters with $p<0.05$. Note: the reference level for the devices is the HeartMate-II (HMII).

```{r plot1, eval = T, results="asis"}
require(reshape2, quietly = T)
df.long <- melt(df, id.vars = colnames(df)[1:13])
groups <- make.names(c("Device Type"))
names(df.long) <- make.names(names(df.long))

invisible(suppressMessages(require(Hmisc, quietly = T)))
stat_sum_df <- function(fun, geom="errorbar", ...) {
    stat_summary(fun.data = fun, geom = geom, width = 1, ...)
}

plots.ts <- mclapply(rownames(qtable), function(this_var){
    lapply(groups, function(this_groups){
        ggplot(subset(df.long, df.long$variable == this_var)) +
            aes(x = Time, y = value, group = PatientID) +
            aes_string(color = this_groups, fill = this_groups) +
            geom_line(alpha = 0.2) + 
            geom_point(alpha = 0.1) + 
            stat_summary(fun.y = mean, aes_string(group = this_groups), geom=c("point"), position = position_dodge(.5)) + 
            stat_summary(fun.y = mean, aes_string(group = this_groups), geom=c("line"), position = position_dodge(.5)) + 
            stat_sum_df(function(x) mean_cl_normal(x, conf.int = 0.68), mapping = aes_string(group = this_groups), position = position_dodge(.5)) + 
            #stat_smooth(aes_string(group = this_groups), method = "loess", span = 1) +
            scale_color_d3() + scale_fill_d3() +
            xlab("Time (days after surgery)") +
            ylab(this_var) + 
            ggtitle(paste(this_var)) +
            theme_classic()
    })
}, mc.cores = detectCores()-1)
names(plots.ts) <- rownames(qtable)

for(ii in c(1:length(plots.ts))){
    for(jj in 1:length(plots.ts[[ii]])){
        sumtable <- suppressMessages(summary(models.device[[rownames(qtable)[ii]]]$model))
        sumtable <- as.data.frame(sumtable$coefficients)[-1, ,drop=F] # drop intercept
        if(!("Pr(>|t|)" %in% colnames(sumtable))) next()
        sigsum <- sumtable[sumtable[,"Pr(>|t|)"] <= 0.05, , drop = F]
        cat("  \n###", rownames(qtable)[ii], "\n")
        print(kable(sigsum[order(sigsum[,"Pr(>|t|)"]),,drop=F], row.names = T) %>%
                  kable_styling(bootstrap_options = c("striped", 
                                                      "hover", 
                                                      "condensed",
                                                      "responsive"),
                                font_size = 12)
        )
        cat("  \n")
        suppressWarnings(print(plots.ts[[ii]][[jj]]))
        cat("  \n")
    }
}

```



## Linear mixed-effect model {.tabset .tabset-fade .tabset-pills}

Next, we analyzed the association of device types with mean biomarker levels over time using a linear mixed effect model, with time as a continuous variable. This model assumes biomarker levels vary linearly with time. We reported all effects that achieved nominal statistical significance ($p<0.05$), while also indicating the Benjamini-Hochberg q-value. 


```{r mixedeffect, eval = T}
suppressMessages(require(lmerTest, quietly = T))
suppressMessages(require(car, quietly = TRUE))

df.device <- df
colnames(df.device) <- make.names(colnames(df), unique = T)

varnames <- colnames(df.device)[bcellcyto]
models.device <- mclapply(varnames, function(this_var){
    this_formula <- as.formula(paste0(this_var, " ~ Device.Type * Time + (1|PatientID)"))
    invisible(suppressMessages(this_model <- lmer(this_formula, data = df.device)))
    this_anova <- Anova(this_model, type = 2)
    pvals <- this_anova$`Pr(>Chisq)`[c(1,2,3)]
    return(list(model = this_model,
                pvals = pvals))
}, mc.cores = detectCores()-1)
names(models.device) <- colnames(df)[bcellcyto]

pvals <- do.call(rbind, lapply(models.device, function(x) x$pvals))
rownames(pvals) <- varnames
colnames(pvals) <- c("Device", "Time", "Device:Time")

qBH <- matrix(p.adjust(pvals, method = "BH"), nrow = nrow(pvals))
rownames(qBH) <- colnames(df)[bcellcyto]
colnames(qBH) <- colnames(pvals)

sigvars <- apply(apply(pvals, 2, function(x) x<=0.05), 1, function(x) sum(x) > 0)
sig.qtable <- qBH[sigvars,][order(apply(qBH[sigvars,], 1, min)),]

qtable <- as.data.frame(signif(sig.qtable, 2))
qtable %>%
    mutate(
        `biomarker` = row.names(.),
        Device = cell_spec(Device, color = ifelse(qtable$Device > 0.05, "grey", "red")),
        `Device:Time` = cell_spec(`Device:Time`, color = ifelse(qtable$`Device:Time` > 0.05, "grey", "red")),
        `Time` = cell_spec(`Time`, color = ifelse(qtable$`Time` > 0.05, "grey", "red"))
    ) %>%
    kable( escape = F,
           digits = 20,
           row.names = T,
           caption = "Significant device-type q-values") %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"),
                  font_size = 12) %>%
    scroll_box(width = "100%")
```



We plotted the average across time for each of the biomarkers that were nominally statistically significant, and indicated specific features responsible for the positive test result by listing the associated model parameters with $p<0.05$. Note: the reference level for the devices is the HeartMate-II (HMII).


```{r plot2, eval = T, results="asis"}
require(reshape2, quietly = T)
df.long <- melt(df, id.vars = colnames(df)[1:13])
groups <- make.names(c("Device Type"))
names(df.long) <- make.names(names(df.long))

invisible(suppressMessages(require(Hmisc, quietly = T)))
stat_sum_df <- function(fun, geom="errorbar", ...) {
    stat_summary(fun.data = fun, geom = geom, width = 1, ...)
}

plots.ts <- mclapply(rownames(qtable), function(this_var){
    lapply(groups, function(this_groups){
        ggplot(subset(df.long, df.long$variable == this_var)) +
            aes(x = Time, y = value, group = PatientID) +
            aes_string(color = this_groups, fill = this_groups) +
            geom_line(alpha = 0.2) + 
            geom_point(alpha = 0.1) + 
            stat_summary(fun.y = mean, aes_string(group = this_groups), geom=c("point"), position = position_dodge(.5)) + 
            stat_summary(fun.y = mean, aes_string(group = this_groups), geom=c("line"), position = position_dodge(.5)) + 
            stat_sum_df(function(x) mean_cl_normal(x, conf.int = 0.68), mapping = aes_string(group = this_groups), position = position_dodge(.5)) + 
            #stat_smooth(aes_string(group = this_groups), method = "loess", span = 1) +
            scale_color_d3() + scale_fill_d3() +
            xlab("Time (days after surgery)") +
            ylab(this_var) + 
            ggtitle(paste(this_var)) +
            theme_classic()
    })
}, mc.cores = detectCores()-1)
names(plots.ts) <- rownames(qtable)

for(ii in c(1:length(plots.ts))){
    for(jj in 1:length(plots.ts[[ii]])){
        sumtable <- suppressMessages(summary(models.device[[rownames(qtable)[ii]]]$model))
        sumtable <- as.data.frame(sumtable$coefficients)[-1, ,drop=F] # drop intercept
        if(!("Pr(>|t|)" %in% colnames(sumtable))) next()
        sigsum <- sumtable[sumtable[,"Pr(>|t|)"] <= 0.05, , drop = F]
        cat("  \n###", rownames(qtable)[ii], "\n")
        print(kable(sigsum[order(sigsum[,"Pr(>|t|)"]),,drop=F], row.names = T) %>%
                  kable_styling(bootstrap_options = c("striped", 
                                                      "hover", 
                                                      "condensed",
                                                      "responsive"),
                                font_size = 12)
        )
        cat("  \n")
        suppressWarnings(print(plots.ts[[ii]][[jj]]))
        cat("  \n")
    }
}



```



## Two-way repeated measures anova {.tabset .tabset-fade .tabset-pills}

Finally, we attempted to model the association of device type with biomarker levels across time using a two-way repeated measures anova. We reported all biomarkers that achieved nominal statistical significance ($p<0.05$). As there were 5 device types and 7 timepoints, but only `r nrow(df) - length(Reduce(intersect, apply(df[,bcellcyto], 2, function(x) which(is.na(x)))))` samples, this model is severely underpowered. We caution that the posterior belief in any of these results should therefore be quite small (as a consequence of Bayes rule).

```{r twowayanova, eval = T}
suppressMessages(require(lmerTest, quietly = T))
suppressMessages(require(car, quietly = TRUE))

df.device <- df
colnames(df.device) <- make.names(colnames(df), unique = T)

varnames <- colnames(df.device)[bcellcyto]
models.device <- mclapply(varnames, function(this_var){
    this_formula <- as.formula(paste0(this_var, " ~ Device.Type * factor(Time) + (1|PatientID)"))
    invisible(suppressMessages(this_model <- lmer(this_formula, data = df.device)))
    this_anova <- Anova(this_model, type = 2)
    pvals <- this_anova$`Pr(>Chisq)`[c(1,2,3)]
    return(list(model = this_model,
                pvals = pvals))
}, mc.cores = detectCores()-1)
names(models.device) <- colnames(df)[bcellcyto]

pvals <- do.call(rbind, lapply(models.device, function(x) x$pvals))
rownames(pvals) <- varnames
colnames(pvals) <- c("Device", "factor(Time)", "Device:factor(Time)")

qBH <- matrix(p.adjust(pvals, method = "BH"), nrow = nrow(pvals))
rownames(qBH) <- colnames(df)[bcellcyto]
colnames(qBH) <- colnames(pvals)

sigvars <- apply(apply(pvals, 2, function(x) x<=0.05), 1, function(x) sum(x) > 0)
sig.qtable <- qBH[sigvars,][order(apply(qBH[sigvars,], 1, min)),]

qtable <- as.data.frame(signif(sig.qtable, 2))
qtable %>%
    mutate(
        `biomarker` = row.names(.),
        Device = cell_spec(Device, color = ifelse(qtable$Device > 0.05, "grey", "red")),
        `Device:factor(Time)` = cell_spec(`Device:factor(Time)`, color = ifelse(qtable$`Device:factor(Time)` > 0.05, "grey", "red")),
        `factor(Time)` = cell_spec(`factor(Time)`, color = ifelse(qtable$`factor(Time)` > 0.05, "grey", "red"))
    ) %>%
    kable( escape = F,
           digits = 20,
           row.names = T,
           caption = "Significant device-type q-values") %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"),
                  font_size = 12) %>%
    scroll_box(width = "100%")
```


We plotted the average across time for each of the biomarkers that were nominally statistically significant, and indicated specific features responsible for the positive test result by listing the associated model parameters with $p<0.05$. Note: the reference level for the devices is the HeartMate-II (HMII).

```{r plot3, eval = T, results="asis"}
require(reshape2, quietly = T)
df.long <- melt(df, id.vars = colnames(df)[1:13])
groups <- make.names(c("Device Type"))
names(df.long) <- make.names(names(df.long))

invisible(suppressMessages(require(Hmisc, quietly = T)))
stat_sum_df <- function(fun, geom="errorbar", ...) {
    stat_summary(fun.data = fun, geom = geom, width = 1, ...)
}

plots.ts <- mclapply(rownames(qtable), function(this_var){
    lapply(groups, function(this_groups){
        ggplot(subset(df.long, df.long$variable == this_var)) +
            aes(x = Time, y = value, group = PatientID) +
            aes_string(color = this_groups, fill = this_groups) +
            geom_line(alpha = 0.2) + 
            geom_point(alpha = 0.1) + 
            stat_summary(fun.y = mean, aes_string(group = this_groups), geom=c("point"), position = position_dodge(.5)) + 
            stat_summary(fun.y = mean, aes_string(group = this_groups), geom=c("line"), position = position_dodge(.5)) + 
            stat_sum_df(function(x) mean_cl_normal(x, conf.int = 0.68), mapping = aes_string(group = this_groups), position = position_dodge(.5)) + 
            #stat_smooth(aes_string(group = this_groups), method = "loess", span = 1) +
            scale_color_d3() + scale_fill_d3() +
            xlab("Time (days after surgery)") +
            ylab(this_var) + 
            ggtitle(paste(this_var)) +
            theme_classic()
    })
}, mc.cores = detectCores()-1)
names(plots.ts) <- rownames(qtable)

for(ii in c(1:length(plots.ts))){
    for(jj in 1:length(plots.ts[[ii]])){
        sumtable <- suppressMessages(summary(models.device[[rownames(qtable)[ii]]]$model))
        sumtable <- as.data.frame(sumtable$coefficients)[-1, ,drop=F] # drop intercept
        if(!("Pr(>|t|)" %in% colnames(sumtable))) next()
        sigsum <- sumtable[sumtable[,"Pr(>|t|)"] <= 0.05, , drop = F]
        cat("  \n###", rownames(qtable)[ii], "\n")
        print(kable(sigsum[order(sigsum[,"Pr(>|t|)"]),], row.names = T) %>%
                  kable_styling(bootstrap_options = c("striped", 
                                                      "hover", 
                                                      "condensed",
                                                      "responsive"),
                                font_size = 12)
        )
        cat("  \n")
        suppressWarnings(print(plots.ts[[ii]][[jj]]))
        cat("  \n")
    }
}



```

