---
title: "Notebook"
author: "Nick Wisniewski"
date: June 28, 2018
output:
  html_document:
    toc: true
    toc_depth: 4
    toc_float: true
    collapsed: true
    number_sections: false
    theme: cosmo
    df_print: kable
    code_folding: hide
---

```{r}
load("data.RData")
df$`Device Type` <- relevel(df$`Device Type`, ref = "HMII")
suppressMessages(require(knitr, quietly = T))
suppressMessages(require(kableExtra, quietly = T))
suppressMessages(require(rmarkdown, quietly = T))
suppressMessages(require(plyr, quietly = T))
suppressMessages(require(dplyr, quietly = T))
suppressMessages(require(ggplot2, quietly = T))
suppressMessages(require(GGally, quietly = T))
suppressMessages(require(parallel, quietly = TRUE))
```


# Raw Data

We show the raw data below. There were `r nrow(df)` rows and `r ncol(df)` columns, consisting of `r nlevels(df$PatientID)` patients taken over `r length(unique(df$Time))` timepoints. However, there is a significant amount of missing data, resulting in only `r nrow(df) - length(Reduce(intersect, apply(df[,14:42], 2, function(x) which(is.na(x)))))` usable datapoints.

```{r, fig.height=10}
missing.ix <- Reduce(intersect, apply(df[,14:42], 2, function(x) which(is.na(x))))
df.raw <- df[-missing.ix,]
df.raw <- df.raw[order(df.raw$PatientID),]
rownames(df.raw) <- 1:nrow(df.raw)
kable(df.raw, 
      digits = 3,
      row.names = T,
      caption = "Raw Data"
      ) %>%
    kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                  font_size = 12) %>%
    scroll_box(width = "100%", height = "300px") 

df.temp <- df
colnames(df.temp) <- make.names(colnames(df), unique = T)
invisible(
    suppressWarnings(
        suppressMessages(
            ggpairs(df.temp, 
                    mapping = aes(color = Survival), 
                    columns = colnames(df.temp)[c(2,4,6,7,8,9,10,11)]) 
        )))
```


# Correlation and Clusters

We computed the cross correlation matrix, and clustered the B-cells. We found one large block, and one smaller block of correlated B-cells; the remaining B-cells were largely uncorrelated.

```{r, fig.height=7}
require(pheatmap, quietly = T)
require(RColorBrewer, quietly = T)
r <- cor(df[,c(2,14:42)], use = "p")
pheatmap(r, 
         color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(100),
         breaks = seq(-1, 1, length.out = 100),
         fontsize = 7,
         cutree_rows = 5,
         cutree_cols = 5
)
```

# Principal Component Analysis {.tabset .tabset-fade .tabset-pills}

We found large variability between individual patients, as well as device types, using PCA.

```{r, eval = T, results='asis'}
suppressMessages(require(ggbiplot, quietly = T))
require(ggsci, quietly = T)

# Efron's double standardization
double_standardize <- function(x, niter = 100) {
    for(i in 1:niter) x <- t(scale(t(scale(x))))
    return(as.data.frame(x))
}

isna <- unique(unlist(apply(df[,14:42], 2, function(x) which(is.na(x)))))
pca <- prcomp(double_standardize(df[-isna, 14:42]), center = TRUE, scale. = TRUE)

colorfun <- function(grouping, ...){
    if(nlevels(factor(grouping)) > 10) scale_color_discrete(...)
    if(nlevels(factor(grouping)) <=10) scale_color_d3(...)
} 

plots.pca <- mclapply(names(df)[1:17], function(this_var){
    this_groups <- df[-isna, this_var]
    if(is.numeric(this_groups)) this_groups <- cut(this_groups, 4)
    
    ggbiplot(pca,
             groups = this_groups,
             ellipse = TRUE,
             alpha = 0.3,
             varname.size = 1.2) + 
        colorfun(this_groups, name = this_var) +
        ggtitle(paste0(this_var, " variability")) +
        theme_classic() 
}, mc.cores = detectCores()-1)

names(plots.pca) <- names(df)[1:17]
#plots.pca$PatientID
#plots.pca$`Device Type`

for(ii in 1:length(plots.pca)){
     cat("  \n##", names(plots.pca)[ii], "\n")
     suppressWarnings(print(plots.pca[[ii]]))
     cat("  \n")
}
```

# Device Types 

We analyzed the devices for correlations with the other variables. 

## Fisher's exact test {.tabset .tabset-fade .tabset-pills}

We analyzed the dependency of device types on the other discrete variables using Fisher's exact test. We found several dependencies (Benjamini-Hochberg $q<0.05$), shown below.

```{r, results="asis"}
isfactor <- which(sapply(df, is.factor))[-1]
contingency <- lapply(isfactor[names(isfactor) != "Device Type"], 
                      function(this_factor){
                          table(df[,this_factor], df$`Device Type`)
                      })

fisher.p <- sapply(contingency, function(this_table){
    fisher.test(this_table, simulate.p.value = T, B = 10000)$p
})
fisher.q <- p.adjust(fisher.p, method = "BH")

signif.ix <- which(fisher.q < 0.05)
signif.order <- sort(fisher.q[signif.ix], index.return = T)$ix
for(this_ix in signif.ix[signif.order]){
    cat("  \n###", names(contingency)[this_ix], "\n")
    cat(paste0("Benjamini-Hochberg qvalue = ", signif(fisher.q[this_ix], 2)),
        ". \n")
    print(kable(contingency[this_ix][[1]],  row.names = T) %>%
        kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                     font_size = 12)
    )
    cat("  \n")
}
```

## Mixed Effect Model

We attempted to analyze the differences in B-cell levels across device types using a mixed effect model (a.k.a. two-way repeated measures ANOVA). Here we report variables that had a statistically significant variance (Benjamini-Hochberg $q<0.05$) across devices, times, or their interaction. As there were 5 different device types, this model is quite underpowered, and the results are probably spurious. However, we reported them for the sake of completeness.

```{r, eval = T}
suppressMessages(require(lmerTest, quietly = T))
suppressMessages(require(car, quietly = TRUE))

df.device <- df
colnames(df.device) <- make.names(colnames(df), unique = T)

varnames <- colnames(df.device)[14:42]
models.device <- mclapply(varnames, function(this_var){
    this_formula <- as.formula(paste0(this_var, " ~ Device.Type * factor(Time) + (1|PatientID)"))
    invisible(suppressMessages(this_model <- lmer(this_formula, data = df.device)))
    this_anova <- Anova(this_model, type = 2)
    pvals <- this_anova$`Pr(>Chisq)`[c(1,2,3)]
    return(list(model = this_model,
                pvals = pvals))
}, mc.cores = detectCores()-1)
names(models.device) <- colnames(df)[14:42]

pvals <- do.call(rbind, lapply(models.device, function(x) x$pvals))
rownames(pvals) <- varnames
colnames(pvals) <- c("Device", "factor(Time)", "Device:factor(Time)")

qBH <- matrix(p.adjust(pvals, method = "BH"), nrow = nrow(pvals))
rownames(qBH) <- colnames(df)[14:42]
colnames(qBH) <- colnames(pvals)

sigvars <- apply(apply(qBH, 2, function(x) x<=0.05), 1, function(x) sum(x) > 0)
sig.qtable <- qBH[sigvars,][order(apply(qBH[sigvars,], 1, min)),]

qtable <- as.data.frame(signif(sig.qtable, 2))
qtable %>%
    mutate(
        `B-cell` = row.names(.),
        Device = cell_spec(Device, color = ifelse(qtable$Device > 0.05, "grey", "red")),
        `Device:factor(Time)` = cell_spec(`Device:factor(Time)`, color = ifelse(qtable$`Device:factor(Time)` > 0.05, "grey", "red")),
        `factor(Time)` = cell_spec(`factor(Time)`, color = ifelse(qtable$`factor(Time)` > 0.05, "grey", "red"))
    ) %>%
    kable( escape = F,
           digits = 20,
           row.names = T,
           caption = "Significant device-type q-values") %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"),
                  font_size = 12) %>%
    scroll_box(width = "100%", height = "300px")
```

## Figures {.tabset .tabset-fade .tabset-pills}

We plotted the average across time for each of the B-cells that showed a statistically significant effect across devices in the above mixed effect models. We draw attention to the features that induced the positive test result, by listing the model parameters with $p<0.05$ in the multivariate fit.

```{r, eval = T, results="asis"}
require(reshape2, quietly = T)
df.long <- melt(df, id.vars = colnames(df)[1:13])
groups <- make.names(c("Device Type"))
names(df.long) <- make.names(names(df.long))

invisible(suppressMessages(require(Hmisc, quietly = T)))
stat_sum_df <- function(fun, geom="errorbar", ...) {
    stat_summary(fun.data = fun, geom = geom, width = 1, ...)
}

plots.ts <- mclapply(rownames(qtable), function(this_var){
    lapply(groups, function(this_groups){
        ggplot(subset(df.long, df.long$variable == this_var)) +
            aes(x = Time, y = value, group = PatientID) +
            aes_string(color = this_groups, fill = this_groups) +
            geom_line(alpha = 0) + 
            geom_point(alpha = 0) + 
            stat_summary(fun.y = mean, aes_string(group = this_groups), geom=c("point"), position = position_dodge(.5)) + 
            stat_summary(fun.y = mean, aes_string(group = this_groups), geom=c("line"), position = position_dodge(.5)) + 
            stat_sum_df(function(x) mean_cl_boot(x, conf.int = 0.68), mapping = aes_string(group = this_groups), position = position_dodge(.5)) + 
            #stat_smooth(aes_string(group = this_groups), method = "loess", span = 1) +
            scale_color_d3() + scale_fill_d3() +
            xlab("Time (days after surgery)") +
            ylab(this_var) + 
            ggtitle(paste(this_var)) +
            theme_classic()
    })
}, mc.cores = detectCores()-1)
names(plots.ts) <- rownames(qtable)

for(ii in c(1:length(plots.ts))){
    for(jj in 1:length(plots.ts[[ii]])){
        sumtable <- suppressMessages(summary(models.device[[rownames(qtable)[ii]]]$model))
        sumtable <- sumtable$coefficients[-1, c(4:5)] # drop intercept
        sigsum <- sumtable[sumtable[,2] <= 0.05, , drop = F]
        cat("  \n###", rownames(qtable)[ii], "\n")
        print(kable(sigsum[order(sigsum[,2]),], row.names = T) %>%
            kable_styling(bootstrap_options = c("striped", 
                                                "hover", 
                                                "condensed",
                                                "responsive"),
                          font_size = 12)
        )
        cat("  \n")
        suppressWarnings(print(plots.ts[[ii]][[jj]]))
        cat("  \n")
    }
}



```


# HeartMate-II

The HeartMate-II (HMII) recipients were the largest group, and we analyzed them by themselves due to the previously observed variability across devices.

```{r, eval = T}
require(reshape2, quietly = T)
df.HMII <- subset(df, df$`Device Type`=="HMII")
df.long <- melt(df.HMII, id.vars = colnames(df)[1:13])

groups <- make.names(c("AgeGreater60", 
                       "Sex",
                       "LowIntermacs",
                       "RVAD", 
                       "Sensitized",
                       "VAD Indication", 
                       #"Device Type", 
                       "Survival",
                       "Outcome"))

names(df.long) <- make.names(names(df.long))

plots.ts <- mclapply(unique(df.long$variable), function(this_var){
    lapply(groups, function(this_groups){
        ggplot(subset(df.long, df.long$variable == this_var)) +
            aes(x = Time, y = value, group = PatientID) +
            aes_string(color = this_groups, fill = this_groups) +
            geom_line(alpha = 0) + 
            geom_point(alpha = 0) + 
            #stat_smooth(aes_string(group = this_groups), method = "loess", span = 1) +
            stat_summary(fun.y = mean, aes_string(group = this_groups), geom=c("point"), position = position_dodge(.5)) + 
            stat_summary(fun.y = mean, aes_string(group = this_groups), geom=c("line"), position = position_dodge(.5)) + 
            stat_sum_df(function(x) mean_cl_boot(x, conf.int = 0.68), mapping = aes_string(group = this_groups), position = position_dodge(.5)) + 
            scale_color_aaas() + scale_fill_aaas() +
            xlab("Time (days after surgery)") +
            ylab(this_var) + 
            ggtitle(paste(this_var)) +
            theme_classic()
    })
}, mc.cores = detectCores()-1)
names(plots.ts) <- unique(df.long$variable)

# for(ii in c(1:length(plots.ts))){
#     for(jj in 1:length(plots.ts[[ii]])){
#         suppressWarnings(print(plots.ts[[ii]][[jj]]))
#     }
# } 

```

## Principal Component Analysis {.tabset .tabset-fade .tabset-pills}

We again found large variability between individual patients using PCA.

```{r, eval = T, results='asis'}
suppressMessages(require(ggbiplot, quietly = T))
require(ggsci, quietly = T)

# Efron's double standardization
double_standardize <- function(x, niter = 100) {
    for(i in 1:niter) x <- t(scale(t(scale(x))))
    return(as.data.frame(x))
}

isna <- unique(unlist(apply(df.HMII[,14:42], 2, function(x) which(is.na(x)))))
pca <- prcomp(double_standardize(df.HMII[-isna, 14:42]), center = TRUE, scale. = TRUE)

colorfun <- function(grouping, ...){
    if(nlevels(factor(grouping)) > 10) scale_color_discrete(...)
    if(nlevels(factor(grouping)) <=10) scale_color_d3(...)
} 

plots.pca <- mclapply(names(df.HMII)[1:17], function(this_var){
    this_groups <- df.HMII[-isna, this_var]
    if(is.numeric(this_groups)) this_groups <- cut(this_groups, 4)
    
    ggbiplot(pca,
             groups = this_groups,
             ellipse = TRUE,
             alpha = 0.3,
             varname.size = 1.2) + 
        colorfun(this_groups, name = this_var) +
        ggtitle(paste0(this_var, " variability")) +
        theme_classic() 
}, mc.cores = detectCores()-1)

names(plots.pca) <- names(df.HMII)[1:17]
#plots.pca$PatientID
#plots.pca$`Device Type`

for(ii in 1:length(plots.pca)){
     cat("  \n###", names(plots.pca)[ii], "\n")
     suppressWarnings(print(plots.pca[[ii]]))
     cat("  \n")
}
```



## Mixed Effect Model

We attempted to analyze the differences in B-cell levels for various features using a mixed effect model (a.k.a. two-way repeated measures ANOVA). Here we report variables that had a statistically significant variance (Benjamini-Hochberg $q<0.05$) across devices, times, or their interaction. 

```{r, eval = T}
suppressMessages(require(lmerTest, quietly = TRUE))
suppressMessages(require(car, quietly = TRUE))
require(reshape2, quietly = TRUE)

df.lmer <- df.HMII
names(df.lmer) <- make.names(names(df.lmer), unique = TRUE)

groupvars.ix <- c(3,4,5,7,8,9,11)
groupvars <- names(df.lmer)[groupvars.ix]

bcells.ix <- c(14:42)
bcells <- names(df.lmer)[bcells.ix]

pvals <- mclapply(groupvars, function(this_groupvar){
    these_pvalues <- lapply(bcells, function(this_bcell){
        this_formula <- as.formula(paste0(this_bcell, " ~ ", this_groupvar, 
                                          " * factor(Time) + (1|PatientID)"))
        suppressMessages(suppressWarnings(this_model <- lmer(this_formula, data = droplevels(df.lmer))))
        this_anova <- Anova(this_model, type = 2)
        this_pvalues <- this_anova$`Pr(>Chisq)`
        names(this_pvalues) <- rownames(this_anova)
        return(this_pvalues)
    })
    pvalues <- do.call(rbind, these_pvalues)
    rownames(pvalues) <- bcells
    return(pvalues)
}, mc.cores = detectCores()-1)
names(pvals) <- groupvars
pvals.matrix <- do.call(cbind, lapply(pvals, function(this_pval) this_pval[,c(1,3)]))

# Benjamini Hochberg
# qBH <- matrix(p.adjust(as.numeric(pvals.matrix), 
#                        method = "BH"), 
#               nrow = nrow(pvals.matrix), 
#               ncol = ncol(pvals.matrix), 
#               byrow = F) 
# rownames(qBH) <- rownames(pvals.matrix)
# colnames(qBH) <- colnames(pvals.matrix)
# rownames(qBH) <- names(df)[bcells.ix]
# qvalsBH.df <- melt(qBH)
# colnames(qvalsBH.df) <- c("B-cell", "parameter", "qvalue")
# qvalsBH.df.ranked <- qvalsBH.df[order(qvalsBH.df$qvalue, decreasing = F),]
# qvalsBH.df.ranked[qvalsBH.df.ranked$qvalue <= 0.3,]

# Local FDR
require(fdrtool, quietly = T)
invisible(suppressMessages(fdrobj <- fdrtool(as.numeric(pvals.matrix), statistic = "pvalue", plot = F, verbose = F)))
qvals.matrix <- matrix(fdrobj$q, nrow = nrow(pvals.matrix), ncol = ncol(pvals.matrix), byrow = F)
rownames(qvals.matrix) <- rownames(pvals.matrix)
colnames(qvals.matrix) <- colnames(pvals.matrix)
rownames(qvals.matrix) <- names(df)[bcells.ix]
qvals.df <- melt(qvals.matrix)
colnames(qvals.df) <- c("B-cell", "parameter", "qvalue")
qvals.df.ranked <- qvals.df[order(qvals.df$qvalue, decreasing = F),]
shortlist <- qvals.df.ranked[qvals.df.ranked$qvalue <= 0.3,]


kable(shortlist, 
      digits = 3,
      row.names = T,
      caption = "Significant results") %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"),
                  font_size = 10) %>%
    scroll_box(width = "100%", height = "300px")
```

## Figures {.tabset .tabset-fade .tabset-pills}

We plotted the average across time for each of the B-cells that showed a statistically significant effect across various factors in the above mixed effect models. We draw attention to the features that induced the positive test result, by listing the model parameters with $p<0.05$ in the multivariate fit.

```{r, eval = T, results='asis'}
require(stringr, quietly = T)
siggroups <- sapply(str_split(shortlist$parameter, ":"), function(x) x[1])
for(ii in 1:nrow(shortlist)){
    this_group <-siggroups[ii]
    cat("  \n###", as.character(shortlist$`B-cell`[ii]), "\n")
    suppressWarnings(print(plots.ts[[shortlist$`B-cell`[ii]]][[which(groups == this_group)]]))
    cat("  \n")
}

```


