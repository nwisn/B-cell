---
title: "Analysis of immune biomarkers after MCS device implantation"
author: "Nicholas Wisniewski"
output:
  html_document:
    toc: true
    toc_depth: 4
    toc_float: true
    collapsed: true
    number_sections: false
    theme: cosmo
    df_print: kable
    code_folding: hide
---

```{r, message=F, warning=F, include=F}
# I can't figure out how to silence the messages, so I must include=F
capture.output(invisible(suppressMessages(suppressWarnings(require(WGCNA, quietly = T)))))
```


```{r load_libraries, message=F, warning=F}
load("data_combined.RData")
df$`Device Type` <- relevel(df$`Device Type`, ref = "HMII")
bc <- 14:42
cyt <- 43:80
bcellcyto <- c(bc,cyt)
groups <- make.names(c("AgeGreater60", 
                       "Sex",
                       "LowIntermacs",
                       "RVAD", 
                       "Sensitized",
                       "VAD Indication", 
                       "Survival"
                       ))
FDRcutoff <- 0.1
pcutoff <- 0.05

# HMII wide
df.HMII <- droplevels(subset(df, df$`Device Type` == "HMII"))

suppressMessages(require(knitr, quietly = T))
suppressMessages(require(kableExtra, quietly = T))
suppressMessages(require(rmarkdown, quietly = T))
suppressMessages(require(plyr, quietly = T))
suppressMessages(require(dplyr, quietly = T))
suppressMessages(require(parallel, quietly = TRUE))
suppressMessages(require(ggsci, quietly = TRUE))
suppressMessages(require(ggplot2, quietly = T))
suppressMessages(require(GGally, quietly = T))
suppressMessages(require(reshape2, quietly = T))
suppressMessages(require(stringr, quietly = T))
suppressMessages(require(lmerTest, quietly = TRUE))
suppressMessages(require(car, quietly = TRUE))
suppressMessages(require(fdrtool, quietly = TRUE))
suppressMessages(require(pheatmap, quietly = TRUE))
suppressMessages(require(RColorBrewer, quietly = TRUE))
require(factoextra, quietly = T)
require(NbClust, quietly = T)
require(gridExtra)

# Efron's double standardization
double_standardize <- function(x, niter = 1000) {
    for(i in 1:niter) x <- t(scale(t(scale(x))))
    return(as.data.frame(x))
}

# Error bars
invisible(suppressMessages(require(Hmisc, quietly = T)))
stat_sum_df <- function(fun, geom="errorbar", ...) {
    stat_summary(fun.data = fun, geom = geom, width = 1, ...)
}

# function that converts pvalues to star indicators
p2stars <- function(p){
    if(p >= 0.1) s <- ""
    if(p < 0.1 & p >= 0.05) s <- "."
    if(p < 0.05 & p >= 0.01) s <- "*"
    if(p < 0.01 & p >= 0.001) s <- "**"
    if(p < 0.001 & p >= 0.0001) s <- "***"
    if(p < 0.0001 & p >= 0) s <- "****"
    return(s)
}

```


# HeartMate-II analysis

`r nlevels(df.HMII$PatientID)` heart-failure patients receiving the Heartmate-II mechanical circulatory support device (MCSD) were sampled at `r length(unique(df.HMII$Time))` timepoints after implantation. Each sample consisted of `r length(bcellcyto)` biomarker measurements -- `r length(bc)` B-cell markers and `r length(cyt)` cytokine markers. Additionally, each patient was associated with `r length(groups)` categorical variables, such as age, sex, interMACS score, and survival. Due to practical limitations, not all samples were complete; after accounting for missing data, there are a total of `r nrow(df.HMII) - length(Reduce(intersect, apply(df.HMII[,bcellcyto], 2, function(x) which(is.na(x)))))` datapoints.


## Specific aims

* Our primary aim was to identify if any of the `r length(bcellcyto)` biomarkers are associated with any of the `r length(groups)` categorical variables, at a false discovery rate of 10%. For this, we used a linear mixed-effect model.

* We also sought to identify any major temporal patterns in the biomarker panel, using clustering.



## Methods

### Dataset

Data was collected from patients who underwent MCSD implantation at a single university medical center. Peripheral blood draws for cytokine and B-cell expression assays were performed at days 0,1,3,5,8,14,21. 

* Cytokine and chemokine concentrations from plasma samples were assayed using the 38-multiplex MILLIPLEX Human Cytokine Chemokine Panel I. 

* HLA class I and II single antigen Luminex antibody profiles were performed via flow cytometry on available samples. Allosensitization was defined as HLA antibody production (mean fluorescence intensity > 5000) during the MCSD course. 

* B-cell multiparameter immunophenotypes were performed by staining peripheral blood mononuclear cells for surface markers using fluorochrome-tagged antibodies against CD3, CD5, CD11b, CD 19, CD24, CD27, CD38, CD268, IgD, IgM, and IgG (One Lambda, Inc.). 


```{r show_raw_data, eval=T, message=FALSE}
missing.ix <- Reduce(intersect, apply(df.HMII[,bcellcyto], 2, function(x) which(is.na(x))))
df.raw <- df.HMII[-missing.ix,]
df.raw <- df.raw[order(df.raw$PatientID),]
rownames(df.raw) <- 1:nrow(df.raw)
kable(df.raw, 
      digits = 3,
      row.names = T,
      caption = "HeartMate-II Raw Data"
) %>%
    kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                  font_size = 12) %>%
    scroll_box(width = "100%", height = "300px") 

```


#### Categorical associations

For each pair of categories, we tested statistical independence using Fisher's exact test. 


```{r , message=FALSE}
# make sure column names are valid R variables before fitting
df.HMII.valid <- df.HMII
colnames(df.HMII.valid) <- make.names(colnames(df.HMII), unique = T)

# get one value per patient
df.HMII.factors <- df.HMII.valid[match(levels(df.HMII.valid$PatientID), df.HMII.valid$PatientID),]

# compute all pairwise contingency tables
factorpairs <- as.list(as.data.frame(combn(groups, 2)))
tables <- lapply(factorpairs, function(this_pair){
    table(df.HMII.factors[, as.character(this_pair[1])], df.HMII.factors[, as.character(this_pair[2])])
})

# compute all Fisher exact tests
fishertests <- lapply(tables, function(this_table) fisher.test(this_table))
fisher.p <- lapply(fishertests, function(x) x$p)
fisher.q <- as.list(p.adjust(fisher.p, method = "BH"))
fisher.OR <- lapply(fishertests, function(x) x$estimate)
fisher.CI <- lapply(fishertests, function(x) x$conf.int)

# error check
fisher.p[is.null(fisher.p)] <- NA
fisher.OR[is.null(fisher.OR)] <- NA
fisher.CI[is.null(fisher.CI)] <- c(NA, NA)

# collect results
fisher.all <- data.frame(
    factorA =  unlist(lapply(factorpairs, function(x) as.character(x[1]))),
    factorB =  unlist(lapply(factorpairs, function(x) as.character(x[2]))),
    OddsRatio = unlist(fisher.OR),
    lowerCL = do.call(rbind, fisher.CI)[,1],
    upperCL = do.call(rbind, fisher.CI)[,2],
    pvalue = unlist(fisher.p),
    qvalue = unlist(fisher.q),
    stars = unlist(lapply(unlist(fisher.p), p2stars)))

qtable <- fisher.all
qtable[,-c(1,2,8)] <- signif(fisher.all[,-c(1,2,8)], 3)
qtable.ordered <- qtable[order(qtable$pvalue),]

qtable.ordered %>%
    # mutate(
    #     pvalue = cell_spec(pvalue, color = ifelse(qtable$pvalue > 0.05, "grey", "red")),
    #     qvalue = cell_spec(qvalue, color = ifelse(qtable$qvalue > 0.05, "grey", "red"))
    # ) %>% 
    kable(escape = F, row.names = F) %>%
    kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                  font_size = 12)
```

####  Conditional distributions of categories

We plotted the conditional distributions for each pair of categorical labels.

```{r ggpairs, fig.height=8, message=FALSE, warning=FALSE}
ggpairs(df.HMII.valid, columns = groups) + ggplot2::theme_grey(base_size = 7)
```



### Linear mixed-effect model

We identified biomarkers associated with the categorical variables using a linear mixed effect model. Our model had a random intercept for each patient, fixed effects for the category and timepoint, and an interaction term. It has the form

$$y_{ij}=b_0 +\sum_{k=1}^p b_k x_{ijk} + v_{i0}+\epsilon_{ij}$$

for $i\in\{1,...,20\}$ subjects, $j\in\{1,...,7\}$ measurements for each subject, and $k\in1,...,p$ predictors or contrasts, where

* $y_{ij}\in\mathbb{R}$ is the response for the $j$-th measurement of the $i$-th subject
* $b_0\in\mathbb{R}$ is the fixed intercept for the model
* $b_k\in\mathbb{R}$ is the fixed slope for the $k$-th predictor or contrast
* $x_{ijk}\in\mathbb{R}$ is the $j$-th measurement of the $k$-th predictor for the $i$-th subject
* $v_{i0}\sim N(0,\sigma_0^2)$ is the random intercept for the $i$-th subject
* $e_{ij}\sim N(0,\sigma_e^2)$ is a Gaussian error term


The fundamental assumptions of this model are:

* the relationship between X and Y is linear
* $x_{ijk}$ and $y_{ij}$ are observed random variables 
* $v_{i0} \sim N(0,\sigma_v^2)$ is an unobserved random variable, being the random intercept for the $i$-th subject
* $\epsilon_{ij}\sim N(0,\sigma_e^2)$ is an unobserved random variable, being the Gaussian error term
* $v_{i0}$ and $e_{ij}$ are independent of one another
* $b_0$ and $b_1$ are unknown constants, being the fixed intercept and fixed slope for the regression model
* $(y_{ij}|x_{ij})\sim N(b_0+b_1 x_{ij}, \sigma_Y^2)$ where $\sigma_Y^2=\sigma_v^2+\sigma_e^2$

In implementing the contrasts and statistical tests in R, we followed the advice found  [here](https://rstudio-pubs-static.s3.amazonaws.com/65059_586f394d8eb84f84b1baaf56ffb6b47f.html) and [here](https://mcfromnz.wordpress.com/2011/03/02/anova-type-iiiiii-ss-explained/), by using zero-sum contrast `contr.sum`, and obtaining type 3 sums of squares using the `car` package. Type 3 sums of squares look like $S(A|B,AB)$, and test a main effect after the other main effect and interaction. The significance estimates are therefore valid in the presence of significant interactions. 

We would have also heeded the [guidelines](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3672519/) on including random slopes for the within factor when testing for interactions, but the number of random effects would have exceeded teh number of observations.


```{r, cache = T}


# make sure column names are valid R variables before fitting
df.HMII.valid <- df.HMII
colnames(df.HMII.valid) <- make.names(colnames(df.HMII), unique = T)

# function to fit a two-way repeated measures anova
anova.fit <- function(this_group, this_variable, this_df){
    this_df$Time <- as.factor(this_df$Time)
    this_formula <- as.formula(paste0(this_variable, " ~ ", this_group, " * Time + (1|PatientID)"))
    # set contrasts
    contrasts(this_df[[this_group]]) <- contr.sum 
    contrasts(this_df$Time) <- contr.sum
    # fit model
    this_model <- lmer(this_formula, data = this_df)
    return(list(model = this_model, group = this_group, variable = this_variable))
}

# function to get stats on the model fit
get.anovatable <- function(anova.fit.obj){
    # unpack
    this_model <- anova.fit.obj$model
    this_variable <- anova.fit.obj$variable
    this_group <- anova.fit.obj$group
    # compute p-values
    this_aov <- as.data.frame(Anova(this_model, type="III"))[-1,]
    # annotate with additional variables
    this_aov$parameter <- rownames(this_aov)
    this_aov$variable <- rep(this_variable, nrow(this_aov))
    this_aov$group <- rep(this_group, nrow(this_aov))
    return(this_aov)
}

# create the list of variable ~ group comparisons to run mclapply over
groups.by.vars <- unlist(lapply(make.names(groups, unique = T), function(this_group){
    lapply(make.names(colnames(df.HMII[,bcellcyto]), unique = T), function(this_variable){
        list(group = this_group, variable = this_variable)
    })
}), recursive = F)

# fit all models in parallel
models.HMII <- mclapply(groups.by.vars, function(this_e){
    anova.fit(this_e$group, this_e$variable, df.HMII.valid)
})

# compute statistics in parallel
anovatable.0 <- mclapply(models.HMII, function(this_model_obj){
    get.anovatable(this_model_obj)
}, mc.cores = detectCores()-1)

# include original variable names and add an index for splitting on later
anovatable <- lapply(1:length(anovatable.0), function(ii){
    this_table <- anovatable.0[[ii]]
    name.ix <- match(unique(this_table$variable), colnames(df.HMII.valid))
    this_table$variable.valid <- this_table$variable
    this_table$variable <- rep(colnames(df.HMII)[name.ix], nrow(this_table))
    this_table$testid <- rep(ii, nrow(this_table))
    this_table
})

```


### False Discovery Rate

In all, there were `r length(anovatable)` models fit, each with `r nrow(anovatable[[1]])` terms, for a total of `r length(anovatable)*nrow(anovatable[[1]])` hypotheses tested. We estimated local false discovery rates and $q$-values using the `fdrtool` package, which produced three figures illustrating the mixture model of the $p$-value distribution and the local false discovery rate.

```{r, fig.height = 12, cache = T}
# compute fdr
models <- as.data.frame(do.call(rbind, anovatable))
fdrobj <- fdrtool(models$`Pr(>Chisq)`, statistic = "pvalue", verbose = F)
models$qval <- fdrobj$qval
models$lfdr <- fdrobj$lfdr
anovatable.fdr <- split(models, models$testid)

```


## Results

We reported all results with $q<0.10$ as statistically significant.

```{r, cache = T}
# collect pvalues and qvalues into matrix
models.fdr <- do.call(rbind, anovatable.fdr)
qmat <- dcast(models.fdr, group+parameter~variable, value.var = "qval")
pmat <- dcast(models.fdr, group+parameter~variable, value.var = "Pr(>Chisq)")

# find significant results and mark with text qvalue
qmask <- signif(qmat[,-c(1,2)], 2)
qmask[qmat[,-c(1,2)] > FDRcutoff] <- ""
keep.signif <- apply(t(qmask), 1, function(x) !all(x == ""))
# 
# # create heatmap of results
# pheatmap(-log10(t(qmat[,-c(1,2)])[keep.signif,c(3,1,2,4:nrow(pmat))]),
#          color = colorRampPalette(brewer.pal(n = 9, name = "Greens"))(4),
#          breaks = c(seq(0, -log10(0.1), length.out = 2),
#                     seq(-log10(0.1)+0.001, max(-log10(t(qmat[,-c(1,2)])[keep.signif,])), length.out = 2)),
#          labels_col = pmat$parameter[c(3,1,2,4:nrow(pmat))],
#          display_numbers = t(qmask)[keep.signif,c(3,1,2,4:nrow(pmat))],
#          number_color = "white",
#          fontsize_number = 6,
#          cluster_cols = F,
#          cluster_rows = F,
#          gaps_col = seq(3, nrow(pmat), by = 3),
#          border_color = NA,
#          legend = F,
#          main = paste0("ANOVA results (FDR=", FDRcutoff, ")"))

# gather significant results into a table
resulttable <- do.call(rbind, apply(which(qmask != "", arr.ind = T), 1, function(x){
    data.frame(biomarker = colnames(qmat)[-c(1,2)][x[2]],
               group = qmat$group[x[1]], 
               parameter = qmat$parameter[x[1]], 
               pvalue = pmat[,-c(1,2)][x[1], x[2]], 
               qvalue = qmat[,-c(1,2)][x[1], x[2]])
}))

resulttable.sort <- resulttable[order(resulttable$pvalue), , drop = F]
resulttable.sort[,c("pvalue","qvalue")] <- signif(resulttable.sort[,c("pvalue","qvalue")], 3)
rownames(resulttable.sort) <- 1:nrow(resulttable.sort)
resulttable.sort %>%
    # mutate(
    #     pvalue = cell_spec(pvalue, color = ifelse(resulttable.sort$pvalue > pcutoff, "grey", "green")),
    #     qvalue = cell_spec(qvalue, color = ifelse(resulttable.sort$qvalue > FDRcutoff, "grey", "green"))
    # ) %>% 
    kable(escape = F, row.names = T) %>%
    kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                  font_size = 10) %>%
    scroll_box(width = "100%")

```




## Figures {.tabset .tabset-fade .tabset-pills}

```{r, results = 'asis', message = F, warning=F}

# long
df.long <- melt(df.HMII, id.vars = colnames(df)[1:13])
names(df.long) <- make.names(names(df.long))

# list of identifiers for significant results to plot
unique_results <- unique(resulttable.sort[,c("biomarker","group")])

# make all timeseries plots
plots.ts <- mclapply(1:nrow(unique_results), function(ii){
    this_var <- as.character(unique_results[ii, "biomarker"])
    this_groups <- as.character(unique_results[ii, "group"])
    this_df.0 <- droplevels(subset(df.long, df.long$variable == this_var))
    this_df <- droplevels(this_df.0[!is.na(this_df.0$value),])
    ggplot(this_df) +
        aes(x = Time, y = value, group = PatientID) +
        aes_string(color = this_groups, fill = this_groups) +
        geom_line(alpha = 0.2) + 
        geom_point(alpha = 0.1) + 
        stat_summary(fun.y = mean, 
                     aes_string(group = this_groups), 
                     geom=c("point"), 
                     position = position_dodge(.5)) + 
        stat_summary(fun.y = mean, 
                     aes_string(group = this_groups), 
                     geom=c("line"), 
                     size = 2, 
                     position = position_dodge(.5)) + 
        # stat_smooth(method = "loess", 
        #             aes_string(group = this_groups), 
        #             size = .01, 
        #             span = 1, 
        #             alpha = 0.1) + 
        stat_sum_df(function(x) mean_cl_normal(x, conf.int = 0.68), 
                    mapping = aes_string(group = this_groups), 
                    position = position_dodge(.5)) + 
        scale_color_aaas() + scale_fill_aaas() +
        xlab("Time (days after surgery)") +
        ylab(this_var) + 
        scale_x_continuous(breaks = unique(this_df$Time)) +
        ggtitle(paste(this_var)) +
        theme_classic()
}, mc.cores = detectCores()-1)
names(plots.ts) <- paste(unique_results$biomarker, unique_results$group, sep = " | ")



# print out results
for(ii in 1:length(plots.ts)){
    cat("  \n###", names(plots.ts)[ii], "\n")
    
    
    testid <- unique(models.fdr$testid[models.fdr$variable == unique_results$biomarker[ii] & 
                                           models.fdr$group == unique_results$group[ii]])
    this_anova <- anovatable.fdr[[testid]][,c("variable", "group", "parameter", "Chisq", "Df", "Pr(>Chisq)", "qval", "lfdr")]
    this_anova$stars <- sapply(this_anova$`Pr(>Chisq)`, p2stars)
    print(this_anova %>%
    # mutate(
    #     pvalue = cell_spec(pvalue, color = ifelse(resulttable.sort$pvalue > pcutoff, "grey", "green")),
    #     qvalue = cell_spec(qvalue, color = ifelse(resulttable.sort$qvalue > FDRcutoff, "grey", "green"))
    # ) %>% 
    kable(escape = F, row.names = F) %>%
    kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                  font_size = 10) %>%
    scroll_box(width = "100%"))
    cat("  \n")
    
    suppressWarnings(print(plots.ts[[ii]]))
    cat("  \n")
    
    model.summary <- summary(models.HMII[[testid]]$model)
    this_summary <- as.data.frame(model.summary$coefficients)
    this_summary$stars <- sapply(this_summary$`Pr(>|t|)`, p2stars)
    print(this_summary %>%
    # mutate(
    #     pvalue = cell_spec(pvalue, color = ifelse(resulttable.sort$pvalue > pcutoff, "grey", "green")),
    #     qvalue = cell_spec(qvalue, color = ifelse(resulttable.sort$qvalue > FDRcutoff, "grey", "green"))
    # ) %>% 
    kable(escape = F, row.names = T) %>%
    kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                  font_size = 10) %>%
    scroll_box(width = "100%"))
    cat("  \n")

}

```



## Identification of clusters

We double-standardized the data ( [Efron 2009](https://projecteuclid.org/euclid.aoas/1254773272)) and computed the correlation matrix for the biomarkers using all pairwise complete data. We then clustered the biomarkers using those correlations, and clustered the samples that remained after removing missing data. We also clustered by time, after collapsing each biomarker to only its mean level.

```{r, message=F}

# color palette for this section
colorfun <- function(nlevels, func = pal_d3, ...){
    if(nlevels > 10) return(standardColors(nlevels))
    if(nlevels <=10) return(func(...)(nlevels))
} 

# annotations for our heatmap
annotation.row <- data.frame("biomarker" = factor(c(rep("B-cell", length(bc)),
                                                    rep("cytokine", length(cyt)))))
annotation.col <- df.raw[,which(make.names(colnames(df.raw), unique = T) %in% groups)]
annotation.colors <- lapply(colnames(annotation.col), function(nam){
    colrs <- colorfun(nlevels(annotation.col[[nam]]))
    names(colrs) <- levels(annotation.col[[nam]])
    return(colrs)
})
names(annotation.colors) <- colnames(annotation.col)
annotation.colors[["biomarker"]] <- colorfun(nlevels(annotation.row$biomarker))
names(annotation.colors[["biomarker"]]) <- levels(annotation.row$biomarker)

# double standardize
df.ds <- df.raw
df.ds[,bcellcyto] <- double_standardize(df.raw[, bcellcyto])
df.patient <- t(na.omit(df.ds[,bcellcyto]))
rownames(annotation.row) <- rownames(df.patient)

# compute silhouette for various biomarker clusters
r.biomarker <- cor(df.ds[, bcellcyto], use = "p")
nbclust <- fviz_nbclust(t(df.ds[, bcellcyto]), 
             hcut, 
             method = c("silhouette"),
             diss = as.dist((1-r.biomarker)/2), 
             k.max = 25) +
     labs(subtitle = "Silhouette method")

# compute optimal number of clusters
nclusters.bicluster <- as.numeric(as.character(nbclust$data$clusters[nbclust$data$y == max(nbclust$data$y)]))

# compute clusters
tree.bicluster <- hclust(as.dist((1-r.biomarker)/2), method = "ward.D2")
bicluster <- list()
bicluster$biomarkers_optimal <- cutree(tree.bicluster, k = nclusters.bicluster)
bicluster$biomarkers <- cutree(tree.bicluster, k = 4) # use 4 to simplify

# update annotations to include clusters
annotation.row$bicluster_optimal <- factor(bicluster$biomarkers_optimal)
annotation.row$bicluster <- factor(bicluster$biomarkers)
annotation.colors$bicluster <- colorfun(nlevels(annotation.row$bicluster), 
                                      func = pal_simpsons)
annotation.colors$bicluster_optimal <- colorfun(nlevels(annotation.row$bicluster_optimal), 
                                              func = pal_simpsons)
names(annotation.colors$bicluster) <- levels(factor(annotation.row$bicluster))
names(annotation.colors$bicluster_optimal) <- levels(factor(annotation.row$bicluster_optimal))

# # # make heatmap
# pheatmap(df.patient,
#          color = colorRampPalette(rev(brewer.pal(n = 10, name = "RdBu")))(100),
#          breaks = c(seq(-max(abs(df.patient), na.rm=T), 0, length.out = 50),
#                     seq(0.001, max(abs(df.patient), na.rm=T), length.out = 50)),
#          fontsize = 7,
#          cutree_rows = nclusters.bicluster,
#          cutree_cols = 2,
#          cluster_cols = T,
#          cluster_rows = tree.bicluster,
#          show_colnames = F,
#          annotation_col = annotation.col,
#          annotation_row = annotation.row,
#          annotation_colors = annotation.colors,
#          clustering_method = "ward.D2"
# )
```



```{r, warning=FALSE, message=FALSE}
# Temporal patterns

compute_module_means <- function(modules, df.ds, metadata.cols = 1:13, FUN = mean){
    nmods <- length(unique(modules))
    module.mean.list <- lapply(1:nmods, function(ii){
        this_names <- names(modules)[modules == ii]
        this_columns <- colnames(df.ds) %in% this_names
        this_mean <- apply(df.ds[,this_columns, drop = F], 1, FUN)
    })
    module.mean.matrix <- do.call(cbind, module.mean.list)
    module.mean.df <- as.data.frame(module.mean.matrix)
    colnames(module.mean.df) <- paste0("module.", unique(modules))
    return(cbind(df.ds[, metadata.cols], module.mean.df))
}

df.modules <- list()
df.modules$bicluster <- compute_module_means(bicluster$biomarkers, df.ds)
df.modules$bicluster_optimal <- compute_module_means(bicluster$biomarkers_optimal, df.ds)

# melt data into longform
df.modules.long <- lapply(df.modules, function(this_df.modules){
    melt(this_df.modules, id.vars = colnames(this_df.modules)[1:13])
})

# this_df <- df.modules.long$bicluster_optimal
# g3 <- ggplot(this_df) +
#         aes(x = as.numeric(as.character(Time)),
#             y = value,
#             color = factor(variable),
#             fill = factor(variable),
#             group = PatientID) +
#         geom_point(alpha = 0.1, size = 1) +
#         geom_line(alpha = 0.2) +
#         xlab("Time (days)") +
#         ylab("Standardized level") +
#         scale_x_continuous(breaks = unique(this_df$Time)) +
#         stat_summary(fun.y = mean,
#                      aes(group = variable),
#                      geom=c("line"),
#                      size = .02,
#                      position = position_dodge(.5)) +
#         stat_smooth(method = "loess",
#                     aes(group = variable),
#                     span = .5,
#                     size = 1,
#                     alpha = 0.1) +
#         stat_summary(fun.y = mean,
#                      aes(group = variable),
#                      geom=c("point"),
#                      position = position_dodge(.5)) +
#         stat_sum_df(function(x) mean_cl_normal(x, conf.int = 0.68),
#                     mapping = aes(group = variable),
#                     position = position_dodge(.5)) +
#         #scale_color_simpsons(name = "Cluster") +
#         #scale_fill_simpsons(name = "Cluster") +
#         theme_classic()
# #print(g3)

```




```{r temporal_clusters, warning=F, message=F}
# Temporal clusters

df.ds.patients.0 <- split(df.ds, df.ds$PatientID)
df.ds.patients <- lapply(df.ds.patients.0, function(this_patient){
    this_patient[match(c(0,1,3,5,8,14,21), this_patient$Time),bcellcyto]
})

varnames <- colnames(df.ds[,bcellcyto])
meanlist <- lapply(varnames, function(this_var){
    temp <- aggregate(df.ds[[this_var]], 
              list(df.ds$Time), 
              FUN = function(x) mean(x, na.rm = T))
    colnames(temp) <- c("Time", "z")
    temp$biomarker <- this_var
    temp
})
names(meanlist) <- varnames

means.long <- do.call(rbind, meanlist)
means.wide.0 <- dcast(means.long, Time ~ biomarker, value.var = "z" )
means.wide <- means.wide.0[,c("Time", colnames(df)[bcellcyto])]

colorfun.time <- function(nlevels, ...){
    if(nlevels > 10) return(standardColors(nlevels))
    if(nlevels <=10) return(pal_d3(...)(nlevels))
} 
annotation.row.time <- data.frame("biomarker" = factor(c(rep("B-cell",29), rep("cytokine",38))))

annotation.colors.time <- lapply(colnames(annotation.row.time), function(nam){
    colrs <- colorfun.time(nlevels(annotation.row.time[[nam]]))
    names(colrs) <- levels(annotation.row.time[[nam]])
    return(colrs)
})
names(annotation.colors.time) <- colnames(annotation.row.time)

df.means <- as.data.frame(t(means.wide[,-1]))
rownames(annotation.row.time) <- rownames(df.means)

# compute optimal number of clusters
nbclust.time <- fviz_nbclust(df.means, 
                        hcut, 
                        method = c("silhouette"), 
                        diss = as.dist((1-cor(t(df.means), use = "p"))/2), 
                        k.max = 25)+
  labs(subtitle = "Silhouette method")

nclusters.timecluster <- as.numeric(as.character(nbclust.time$data$clusters[nbclust.time$data$y == max(nbclust.time$data$y)]))
```

### Choosing the optimal number of clusters

To determine the optimal number of clusters, we maximized the average silhouete width using the `factoextra` and `NbClust` packages.

```{r}
a <- nbclust + ggtitle("Optimal number of biomarker clusters")
b <- nbclust.time + ggtitle("Optimal number of timeclusters")
grid.arrange(a,b,ncol = 1)

```



```{r}
# Temporal patterns

# do optimal clustering
tree.timecluster <- hclust(as.dist((1-cor(t(df.means), use = "p"))/2), 
               method = "ward.D2")
timeclusters <- cutree(tree.timecluster, k = nclusters.timecluster) # optimal number of clusters

# update annotations
annotation.row.time$time_cluster <- timeclusters
annotation.colors.time$time_cluster <- colorfun(nlevels(factor(annotation.row.time$time_cluster)))
names(annotation.colors.time$time_cluster) <- factor(unique(annotation.row.time$time_cluster))

# # add in clusters from the first clustering
# annotation.row.time$bicluster_optimal <- annotation.row$bicluster_optimal
# annotation.colors.time$bicluster_optimal <- annotation.colors$bicluster_optimal
# annotation.row.time$bicluster <- annotation.row$bicluster
# annotation.colors.time$bicluster <- annotation.colors$bicluster

hits <- as.character(unique(resulttable$biomarker))
annotation.row.hits <- data.frame(significant = rep(0, nrow(annotation.row)), 
                                  row.names = rownames(annotation.row))
annotation.row.hits$significant[rownames(annotation.row) %in% hits] <- 1

```

### Biclustering patterns

```{r, fig.height=10}
# make biclustering heatmap
pheatmap(df.patient, 
         color = colorRampPalette(rev(brewer.pal(n = 10, name = "RdBu")))(100),
         breaks = c(seq(-max(abs(df.patient), na.rm=T), 0, length.out = 50), 
                    seq(0.001, max(abs(df.patient), na.rm=T), length.out = 50)),
         fontsize = 7,
         cutree_rows = nclusters.bicluster,
         cutree_cols = 2,
         cluster_cols = T,
         cluster_rows = tree.bicluster,
         show_colnames = F,
         annotation_col = annotation.col,
         #annotation_row = annotation.row.time,
         # annotation_row = cbind(annotation.row, 
         #                        time_cluster = annotation.row.time$time_cluster),
         annotation_row = cbind(annotation.row.time[,1,drop=F],
                                annotation.row.time[,2,drop=F],
                                annotation.row[,c(3,2),drop=F],
                                annotation.row.hits[,1,drop=F]),
         #annotation_colors = c(annotation.colors, annotation.colors.time),
         annotation_colors = c(annotation.colors, annotation.colors.time),
         clustering_method = "ward.D2",
         main = "Clusters"
)
```

### Temporal patterns

```{r, fig.height=9}
pheatmap(df.means, 
         color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(100),
         breaks = c(seq(-max(abs(df.means), na.rm=T), 0, length.out = 50), 
                    seq(0.001, max(abs(df.means), na.rm=T), length.out = 50)),
         fontsize = 7,
         cutree_rows = 4,
         cutree_cols = 1,
         cluster_cols = F,
         cluster_rows = tree.timecluster,
         #annotation_col = annotation.col,
         # annotation_row = cbind(annotation.row, 
         #                        time_cluster = factor(annotation.row.time$time_cluster)),
         annotation_row = cbind(annotation.row.time[,1,drop=F], 
                                annotation.row.time[,2,drop=F],
                                annotation.row[,c(3,2),drop=F],
                                annotation.row.hits[,1,drop=F]),
         annotation_colors = c(annotation.colors, annotation.colors.time),
         clustering_method = "ward.D2",
         labels_col = means.wide$Time,
         border_color = NA,
         main = "Temporal Clusters"
)

```

We tested for overlap between the biomarker clusters and the timeclusters using Fisher's exact test.

```{r}
this_table <- table(cbind(annotation.row.time[,2,drop=F],
                          annotation.row[, 3, drop=F]))
this_table  
fisher.test(this_table)
```

We tested for overlap between the statistically significant biomarkers and the optimal biomarker clusters using Fisher's exact test.

```{r}
this_table <- table(cbind(annotation.row[,2, drop=F],
                          annotation.row.hits[,1, drop=F]))
this_table  
fisher.test(this_table)
```


We tested for overlap between the statistically significant biomarkers and the timeclusters using Fisher's exact test.

```{r}
this_table <- table(cbind(annotation.row.time[,2, drop=F],
                          annotation.row.hits[,1, drop=F]))
this_table  
fisher.test(this_table)
```



We tested for overlap between statistically significant biomarkers and their biomarker type.

```{r}
this_table <- table(cbind(annotation.row[,1, drop=F],
                          annotation.row.hits[,1, drop=F]))
this_table  
fisher.test(this_table)
```

We tested for overlap between optimal biomarker clusters and biomarker type.

```{r}
this_table <- table(cbind(annotation.row[,1, drop=F],
                          annotation.row[,2, drop=F]))
this_table  
fisher.test(this_table)
```

We tested for overlap between biomarker metaclusters and biomarker type.

```{r}
this_table <- table(cbind(annotation.row[,1, drop=F],
                          annotation.row[,3, drop=F]))
this_table  
fisher.test(this_table)
```

We tested for overlap between timeclusters and biomarker type.


```{r}
this_table <- table(cbind(annotation.row[,1, drop=F],
                          annotation.row.time[,2, drop=F]))
this_table  
fisher.test(this_table)
```


### Timecluster Timeseries

We depicted each biomarker cluster's temporal pattern as a smooth function of time, using a LOESS regression model. There are clear temporal dynamics occurring at multiple timescales.

```{r, warning=F, message=F}
colnames(df.means) <- unique(means.long$Time)
df.means$timecluster <- factor(timeclusters)
df.means$biomarker <- rownames(df.means)

df.clustermeans <- melt(df.means, id.vars = c("biomarker", "timecluster"), variable.name = "Time", value.name = "z")

gg.time <- ggplot(df.clustermeans) + 
    aes(x=as.numeric(as.character(Time)), y=z, 
        color = timecluster, 
        group = biomarker, 
        fill = timecluster) + 
    geom_point(alpha = 0.1, size = 1) + 
    geom_line(alpha = 0.2) +
    xlab("Time (days)") +
    ylab("Standardized level (z-score)") +
    ggtitle("Temporal biomarker clusters") +
    scale_x_continuous(breaks = as.numeric(as.character(unique(df.clustermeans$Time)))) +
    stat_summary(fun.y = mean, 
                 aes(group = timecluster), 
                 geom=c("line"), 
                 size = .02, 
                 position = position_dodge(.5)) +
    stat_smooth(method = "loess", 
                aes(group = timecluster), 
                span = .6, 
                size = 1, 
                alpha = 0.2) +
    stat_summary(fun.y = mean, 
                 aes(group = timecluster), 
                 geom=c("point"), 
                 position = position_dodge(.5)) +
    stat_sum_df(function(x) mean_cl_boot(x, conf.int = 0.68), 
                mapping = aes(group = timecluster), 
                position = position_dodge(.5)) + 
    scale_color_d3() + 
    scale_fill_d3() + 
    theme_classic()

print(gg.time)
```


