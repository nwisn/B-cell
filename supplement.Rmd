---
title: "Temporal expression of cytokines and B-cell phenotypes during mechanical circulatory support"
subtitle: "Supplemental material"
author: "Nicholas Wisniewski \n\n"
abstract: This Rmarkdown notebook performs all of the statistical analysis for the associated manuscript. We included it in an effort to improve reproducibilty, by providing full transparency concerning our statistical methods. After downloading the dataset and installing all the required R packages, this entire html file (including all the figures) can be created using Knitr. 
output:
  html_document:
    toc: true
    toc_depth: 4
    toc_float: true
    collapsed: true
    number_sections: true
    fig_caption: true
    theme: flatly
    highlight: zenburn
    df_print: kable
    code_folding: hide
---

```{r, message=F, warning=F, include=F}
# I can't figure out how to silence the messages, so I must include=F
capture.output(invisible(suppressMessages(suppressWarnings(require(WGCNA, quietly = T)))))
```


```{r load_libraries, message=F, warning=F}
# load libraries
required_packages <- c("knitr",
                       "kableExtra",
                       "rmarkdown",
                       "plyr",
                       "dplyr",
                       "parallel",
                       "ggsci",
                       "ggplot2",
                       "GGally",
                       "reshape2",
                       "stringr",
                       "lmerTest",
                       "car",
                       "fdrtool",
                       "pheatmap",
                       "RColorBrewer",
                       "factoextra",
                       "NbClust",
                       "gridExtra",
                       "emmeans")
invisible(temp <- lapply(required_packages, function(x) require(x, quietly = T, character.only = TRUE) ))

# load data
load("data_combined.RData")
df$`Device Type` <- relevel(df$`Device Type`, ref = "HMII")

# subset to only HMII patients
df.HMII <- droplevels(subset(df, df$`Device Type` == "HMII"))

# set options
bc <- 14:42 # col index of b-cells in df
cyt <- 43:80 # col index of cytokines in df
bcellcyto <- c(bc,cyt)

# set patient groups
groups <- make.names(c("AgeGreater60", 
                       "Sex",
                       "LowIntermacs",
                       "RVAD", 
                       "Sensitized",
                       "VAD Indication", 
                       "Survival"
                       ))

# set significance requirements
FDRcutoff <- 0.1
pcutoff <- 0.05



# Efron's double standardization
double_standardize <- function(x, niter = 1000) {
    for(i in 1:niter) x <- t(scale(t(scale(x))))
    return(as.data.frame(x))
}

# Error bars
invisible(suppressMessages(require(Hmisc, quietly = T)))
stat_sum_df <- function(fun, geom="errorbar", ...) {
    stat_summary(fun.data = fun, geom = geom, width = 1, ...)
}

# function that converts pvalues to star indicators
p2stars <- function(p){
    if(is.null(p)) return(".")
    if(is.na(p)) return(".")
    if(p >= 0.1) s <- "."
    if(p < 0.1 & p >= 0.05) s <- ".."
    if(p < 0.05 & p >= 0.01) s <- ".*"
    if(p < 0.01 & p >= 0.001) s <- ".**"
    if(p < 0.001 & p >= 0.0001) s <- ".***"
    if(p < 0.0001 & p >= 0) s <- ".****"
    return(s)
}

```


# Introduction

**Background**: `r nlevels(df.HMII$PatientID)` heart-failure patients receiving the Heartmate-II mechanical circulatory support device (MCSD) were sampled at `r length(unique(df.HMII$Time))` timepoints after implantation. Each sample consisted of `r length(bcellcyto)` biomarker measurements -- `r length(bc)` B-cell markers and `r length(cyt)` cytokine markers. Additionally, each patient was associated with `r length(groups)` categorical variables, such as age, sex, interMACS score, and survival. Due to practical limitations, not all samples were complete; after accounting for missing data, there are a total of `r nrow(df.HMII) - length(Reduce(intersect, apply(df.HMII[,bcellcyto], 2, function(x) which(is.na(x)))))` datapoints.

**Specific Aims**: We had the following two specific aims: (1) Our primary aim was to identify if and how any of the `r length(bcellcyto)` biomarkers are associated with any of the `r length(groups)` categorical variables. (2) We also sought to describe any global patterns in the set of biomarkers, such as temporal patterns.

**Methods**: Our methods can be summarized sequentially according to the specific aims: 

1. To identify biomarkers with interesting associations, we used a linear mixed effect model to model group or time effects, or group effects that changed in time. We estimated the local false discovery rate of these results, and reported results with $q<$ `r FDRcutoff`. 

2. To identify specific timepoints where group effects occur, we did a post-hoc analysis using estimated marginal means based on the mixed effect model. We adjusted the statistical significance of all results using the Benjamini-Hochberg method. 

3. To identify biomarker clusters, we biclustered the standardized biomarkers and samples. We also clustered biomarkers by temporal similarity, using the marginal means of each standarized biomarker at every timepoint. We computed the optimal number of clusters for both approaches by maximizing average silhouette width.

4. We related biomarker clusters and temporal clusters to each other, and to the list of significant biomarkers found in (2), using Fisher's exact test.



## Dataset

Data was collected from patients who underwent MCSD implantation at a single university medical center. Peripheral blood draws for cytokine and B-cell expression assays were performed at days 0,1,3,5,8,14,21. Cytokine and chemokine concentrations from plasma samples were assayed using the 38-multiplex MILLIPLEX Human Cytokine Chemokine Panel I. HLA class I and II single antigen Luminex antibody profiles were performed via flow cytometry on available samples. Allosensitization was defined as HLA antibody production (mean fluorescence intensity > 5000) during the MCSD course. B-cell multiparameter immunophenotypes were performed by staining peripheral blood mononuclear cells for surface markers using fluorochrome-tagged antibodies against CD3, CD5, CD11b, CD 19, CD24, CD27, CD38, CD268, IgD, IgM, and IgG (One Lambda, Inc.). 


```{r show_raw_data, eval=T, message=FALSE}
missing.ix <- Reduce(intersect, apply(df.HMII[,bcellcyto], 2, function(x) which(is.na(x))))
df.raw <- df.HMII[-missing.ix,]
df.raw <- df.raw[order(df.raw$PatientID),]
rownames(df.raw) <- 1:nrow(df.raw)

kable(df.raw, 
      digits = 3,
      row.names = T,
      caption = "Table 1: Raw data"
) %>%
    kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                  font_size = 12) %>%
    scroll_box(width = "100%", height = "300px") 

```


## Categorical associations

For each pair of categories, we tested statistical independence using Fisher's exact test, and ranked the results by $p$-value.


```{r , message=FALSE}
# make sure column names are valid R variables before fitting
df.HMII.valid <- df.HMII
colnames(df.HMII.valid) <- make.names(colnames(df.HMII), unique = T)

# get one value per patient
df.HMII.factors <- df.HMII.valid[match(levels(df.HMII.valid$PatientID), df.HMII.valid$PatientID),]

# compute all pairwise contingency tables
factorpairs <- as.list(as.data.frame(combn(groups, 2)))
tables <- lapply(factorpairs, function(this_pair){
    table(df.HMII.factors[, as.character(this_pair[1])], df.HMII.factors[, as.character(this_pair[2])])
})

# compute all Fisher exact tests
fishertests <- lapply(tables, function(this_table) fisher.test(this_table))
fisher.p <- lapply(fishertests, function(x) x$p)
fisher.q <- as.list(p.adjust(fisher.p, method = "BH"))
fisher.OR <- lapply(fishertests, function(x) x$estimate)
fisher.CI <- lapply(fishertests, function(x) x$conf.int)

# error check
fisher.p[is.null(fisher.p)] <- NA
fisher.OR[is.null(fisher.OR)] <- NA
fisher.CI[is.null(fisher.CI)] <- c(NA, NA)

# collect results
fisher.all <- data.frame(
    factorA =  unlist(lapply(factorpairs, function(x) as.character(x[1]))),
    factorB =  unlist(lapply(factorpairs, function(x) as.character(x[2]))),
    OddsRatio = unlist(fisher.OR),
    lowerCL = do.call(rbind, fisher.CI)[,1],
    upperCL = do.call(rbind, fisher.CI)[,2],
    pvalue = unlist(fisher.p),
    qvalue = unlist(fisher.q),
    stars = unlist(lapply(unlist(fisher.p), p2stars)))

qtable <- fisher.all
qtable[,-c(1,2,8)] <- signif(fisher.all[,-c(1,2,8)], 3)
qtable.ordered <- qtable[order(qtable$pvalue),]

qtable.ordered %>%
    kable(escape = F, row.names = F, caption = "Table 2: Categorical associations") %>%
    kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                  font_size = 12)
```



We plotted the conditional distributions for each pair of categorical labels, using the `GGally` package.

```{r ggpairs, fig.height=8, message=FALSE, warning=FALSE, cache=TRUE, fig.cap="Figure 1: Conditional distributions"}
ggpairs(df.HMII.valid, columns = groups) + ggplot2::theme_grey(base_size = 7)
```


# Identifying biomarker associations

## Linear mixed-effect model

We identified statistical associations in the longitudinal data using a linear mixed effect model implemented in the `lmerTest` package, which builds upon the commonly used `lme4` package. We specifically used a random intercept model, of the form 

`lmer(y ~ Group + Time + Group:Time + (1|PatientID))`, 

where `y` is a biomarker, `Group` and `Time` are both factor variables, `Group:Time` denotes their interaction, and the `(1|PatientID)` term specifies a random intercept for each patient to account for the repeated measures. There are therefore 3 hypotheses being tested -- one for each of the terms in this model. Namely, the first tests the equivalence of means across group levels, the second tests the equivalence of means across timepoints, and the third tests that the effect between group levels changes in time.

In implementing the proper contrasts and statistical tests in R, we followed the recommendations  [here](https://rstudio-pubs-static.s3.amazonaws.com/65059_586f394d8eb84f84b1baaf56ffb6b47f.html) and [here](https://mcfromnz.wordpress.com/2011/03/02/anova-type-iiiiii-ss-explained/), by using the zero-sum contrast `contr.sum`, and conducting tests based on the type-III sums of squares by using the `Anova(..., type="III")` function in the `car` package. Type-III sums of squares test a main effect after the other main effect and interaction. The significance estimates are therefore valid in the presence of significant interactions. 


```{r lmer, cache = TRUE}


# make sure column names are valid R variables before fitting
df.HMII.valid <- df.HMII
colnames(df.HMII.valid) <- make.names(colnames(df.HMII), unique = T)

# function to fit a two-way repeated measures anova
anova.fit <- function(this_group, this_variable, this_df){
    this_df$Time <- as.factor(this_df$Time)
    this_formula <- as.formula(paste0(this_variable, " ~ ", this_group, " * Time + (1|PatientID)"))
    # set contrasts
    contrasts(this_df[[this_group]]) <- contr.sum 
    contrasts(this_df$Time) <- contr.sum
    # fit model
    this_model <- lmer(this_formula, data = this_df)
    return(list(model = this_model, group = this_group, variable = this_variable))
}

# function to get stats on the model fit
get.anovatable <- function(anova.fit.obj){
    # unpack
    this_model <- anova.fit.obj$model
    this_variable <- anova.fit.obj$variable
    this_group <- anova.fit.obj$group
    # compute p-values
    this_aov <- as.data.frame(Anova(this_model, type="III"))[-1,]
    # annotate with additional variables
    this_aov$parameter <- rownames(this_aov)
    this_aov$variable <- rep(this_variable, nrow(this_aov))
    this_aov$group <- rep(this_group, nrow(this_aov))
    return(this_aov)
}

# create the list of variable ~ group comparisons to run mclapply over
groups.by.vars <- unlist(lapply(make.names(groups, unique = T), function(this_group){
    lapply(make.names(colnames(df.HMII[,bcellcyto]), unique = T), function(this_variable){
        list(group = this_group, variable = this_variable)
    })
}), recursive = F)

# fit all models in parallel
models.HMII <- mclapply(groups.by.vars, function(this_e){
    anova.fit(this_e$group, this_e$variable, df.HMII.valid)
})

# compute statistics in parallel
anovatable.0 <- mclapply(models.HMII, function(this_model_obj){
    get.anovatable(this_model_obj)
}, mc.cores = detectCores()-1)

# include original variable names and add an index for splitting on later
anovatable <- lapply(1:length(anovatable.0), function(ii){
    this_table <- anovatable.0[[ii]]
    name.ix <- match(unique(this_table$variable), colnames(df.HMII.valid))
    this_table$variable.valid <- this_table$variable
    this_table$variable <- rep(colnames(df.HMII)[name.ix], nrow(this_table))
    this_table$testid <- rep(ii, nrow(this_table))
    this_table
})

```


## Local false discovery rate

In all, there were `r length(anovatable)` models fit, each with `r nrow(anovatable[[1]])` terms, for a total of `r length(anovatable)*nrow(anovatable[[1]])` hypotheses tested. We estimated local false discovery rates and $q$-values using the `fdrtool` package, which alsp produced three figures illustrating the mixture model of the $p$-value distribution and the local false discovery rate.

```{r fdr, fig.height = 12, cache = TRUE, fig.cap="Figure 2: Local false discovery rate"}
# compute fdr
models <- as.data.frame(do.call(rbind, anovatable))
fdrobj <- fdrtool(models$`Pr(>Chisq)`, statistic = "pvalue", verbose = F)
models$qval <- fdrobj$qval
models$lfdr <- fdrobj$lfdr
anovatable.fdr <- split(models, models$testid)

```


## Statistically significant results

We ranked the discoveries by $p$-value, and reported all results with $q<$ `r FDRcutoff` as statistically significant.

```{r signifresults, cache = TRUE}
# collect pvalues and qvalues into matrix
models.fdr <- do.call(rbind, anovatable.fdr)
qmat <- dcast(models.fdr, group+parameter~variable, value.var = "qval")
pmat <- dcast(models.fdr, group+parameter~variable, value.var = "Pr(>Chisq)")

# find significant results and mark with text qvalue
qmask <- signif(qmat[,-c(1,2)], 2)
qmask[qmat[,-c(1,2)] > FDRcutoff] <- ""
keep.signif <- apply(t(qmask), 1, function(x) !all(x == ""))
# 
# # create heatmap of results
# pheatmap(-log10(t(qmat[,-c(1,2)])[keep.signif,c(3,1,2,4:nrow(pmat))]),
#          color = colorRampPalette(brewer.pal(n = 9, name = "Greens"))(4),
#          breaks = c(seq(0, -log10(0.1), length.out = 2),
#                     seq(-log10(0.1)+0.001, max(-log10(t(qmat[,-c(1,2)])[keep.signif,])), length.out = 2)),
#          labels_col = pmat$parameter[c(3,1,2,4:nrow(pmat))],
#          display_numbers = t(qmask)[keep.signif,c(3,1,2,4:nrow(pmat))],
#          number_color = "white",
#          fontsize_number = 6,
#          cluster_cols = F,
#          cluster_rows = F,
#          gaps_col = seq(3, nrow(pmat), by = 3),
#          border_color = NA,
#          legend = F,
#          main = paste0("ANOVA results (FDR=", FDRcutoff, ")"))

# gather significant results into a table
resulttable <- do.call(rbind, apply(which(qmask != "", arr.ind = T), 1, function(x){
    data.frame(biomarker = colnames(qmat)[-c(1,2)][x[2]],
               group = qmat$group[x[1]], 
               parameter = qmat$parameter[x[1]], 
               pvalue = pmat[,-c(1,2)][x[1], x[2]], 
               qvalue = qmat[,-c(1,2)][x[1], x[2]],
               stars = p2stars(pmat[,-c(1,2)][x[1], x[2]]))
}))

resulttable.sort <- resulttable[order(resulttable$pvalue), , drop = F]
resulttable.sort[,c("pvalue","qvalue")] <- signif(resulttable.sort[,c("pvalue","qvalue")], 3)
rownames(resulttable.sort) <- 1:nrow(resulttable.sort)
resulttable.sort %>%
    # mutate(
    #     pvalue = cell_spec(pvalue, color = ifelse(resulttable.sort$pvalue > pcutoff, "grey", "green")),
    #     qvalue = cell_spec(qvalue, color = ifelse(resulttable.sort$qvalue > FDRcutoff, "grey", "green"))
    # ) %>% 
    kable(escape = F, row.names = T, caption = "Table 3: Statistically significant results") %>%
    kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                  font_size = 10) %>%
    scroll_box(width = "100%")

```

## Post-hoc tests


```{r posthoc, message = F, warning = F, cache = TRUE}
# long
df.long <- melt(df.HMII, id.vars = colnames(df)[1:13])
names(df.long) <- make.names(names(df.long))

# list of identifiers for significant results to plot
unique_results <- unique(resulttable.sort[,c("biomarker","group")])

# compute group means and CI using emmeans
posthoc.means <- lapply(1:nrow(unique_results), function(ii){
     testid <- unique(models.fdr$testid[models.fdr$variable == unique_results$biomarker[ii] & 
                                        models.fdr$group == unique_results$group[ii]])
     posthoc_group <- emmeans(models.HMII[[testid]]$model, 
                             as.character(unique_results$group[ii]), 
                             by = "Time"
                             #lmer.df = "satterthwaite"
                             )
     return(posthoc_group)
})

# compute posthoc tests
posthoc.tests.0 <- lapply(posthoc.means, function(this_means){
     tests <- contrast(this_means, "pairwise", reverse = T)
     posthoc_summary <- rbind(tests, adjust = "none")
     posthoc.df <- as.data.frame(posthoc_summary)
     #posthoc.df$bonferroni <- p.adjust(posthoc.df$p.value, method = "bonferroni")
     #posthoc.df$stars <- sapply(posthoc.df$p.value, p2stars)
     return(posthoc.df)
})

# get longform for FDR adjustment
posthoc.tests.all <- do.call(rbind, lapply(1:length(posthoc.tests.0), function(ii){
    posthoc.tests.0[[ii]]$id <- rep(ii, nrow(posthoc.tests.0[[ii]]))
    posthoc.tests.0[[ii]]
}))

# compute q-values over all tests
posthoc.tests.all$q.value <- p.adjust(posthoc.tests.all$p.value, method = "BH")
posthoc.tests.all$stars <- sapply(posthoc.tests.all$p.value, p2stars)
posthoc.tests <- split(posthoc.tests.all, posthoc.tests.all$id)

# collapse posthoc.means into dataframes for plotting
posthoc.means.df <- lapply(posthoc.means, function(this_means){
    this_df <- as.data.frame(this_means)
    this_df
})


```


We did posthoc tests for all mixed effect models previously flagged as significant ($q<$ `r FDRcutoff`). Each grouping was evaluated at every timepoint, using the `emmeans` package to compute confidence intervals and statistical significance of the observed effects.

The `emmeans` package package provides methods for obtaining estimated marginal means (EMMs, also known as least-squares means) for factor combinations in mixed-effect models. Estimated marginal means (see [Searle et al. 1980](https://doi.org/10.1080/00031305.1980.10483031)) are popular for summarizing linear models that include factors. According to its documentation, the EMMs are based on the mixed-effect model â€“ not directly on data. They are computed on a reference grid consisting of all combinations of factor levels, with each covariate set to its average. EMMs are then predictions on this reference grid, or marginal averages thereof (equally weighted by default). For balanced experimental designs, they are just the marginal means. For unbalanced data, they in essence estimate the marginal means you would have observed that the data arisen from a balanced experiment.

After all models were evaluated, we adjusted the `r nrow(na.omit(posthoc.tests.all))` resulting $p$-values using the Benjamini-Hochberg method to obtain $q$-values.

## Post-hoc figures {.tabset .tabset-fade .tabset-pills}

We plotted results for each of the statistically significant associations ($q<$ `r FDRcutoff`). We plotted time on the x-axis, and biomarker level on the y-axis, with patients in different groups shown using different colors. Values for each individual patient are shown in the background with high transparency. Superimposed on top are the estimated marginal means and standard error bars found by `emmeans`, which we pieced together for display using LOESS regression.

```{r timeplots, results = 'asis', message = F, warning=F, cache=TRUE, fig.cap = "Figure 3: Biomarker profile"}

# make all timeseries plots
plots.ts <- mclapply(1:nrow(unique_results), function(ii){
    this_var <- as.character(unique_results[ii, "biomarker"])
    this_groups <- as.character(unique_results[ii, "group"])
    this_df.0 <- droplevels(subset(df.long, df.long$variable == this_var))
    this_df <- droplevels(this_df.0[!is.na(this_df.0$value),]) # drop NAs
    
    # get emmeans with CI
    this_posthoc <- posthoc.means.df[[ii]]
    
    this_df.0 <- droplevels(subset(df.long, df.long$variable == this_var))
    this_df <- droplevels(this_df.0[!is.na(this_df.0$value),])
    
    gg.em <- ggplot(this_posthoc) +
        aes(x = as.numeric(as.character(Time)), y = emmean) + 
        aes_string(group = this_groups, 
                   color = this_groups, 
                   fill = this_groups) +
        geom_line(data = this_df, 
                  aes(group = PatientID,
                      y = value), 
                      alpha = .2, 
                      position=position_dodge(0.5)) +
        geom_point(data = this_df, 
                  aes(group = PatientID,
                      y = value), 
                      alpha = .1, 
                      position=position_dodge(0.5)) +
        geom_point(alpha = 1, position=position_dodge(0.5)) + 
        geom_errorbar(aes(ymin=emmean-SE, ymax=emmean+SE), width=1,
                      position=position_dodge(0.5)) +
        stat_smooth(method = "loess",
                    aes_string(group = this_groups),
                    size = 1,
                    span = .5,
                    se = F,
                    alpha = 0.1,
                    position=position_dodge(0.5)) +
        scale_color_aaas() + scale_fill_aaas() +
        xlab("Time (days after surgery)") +
        ylab(this_var) + 
        scale_x_continuous(breaks = unique(this_df$Time)) +
        ggtitle(paste(this_var)) +
        theme_classic()
    gg.em
}, mc.cores = detectCores()-1)

names(plots.ts) <- paste(unique_results$biomarker, unique_results$group, sep = " | ")



# # make all timeseries plots
# plots.ts <- mclapply(1:nrow(unique_results), function(ii){
#     this_var <- as.character(unique_results[ii, "biomarker"])
#     this_groups <- as.character(unique_results[ii, "group"])
#     this_df.0 <- droplevels(subset(df.long, df.long$variable == this_var))
#     this_df <- droplevels(this_df.0[!is.na(this_df.0$value),])
#     ggplot(this_df) +
#         aes(x = Time, y = value, group = PatientID) +
#         aes_string(color = this_groups, fill = this_groups) +
#         geom_line(alpha = 0.2) + 
#         geom_point(alpha = 0.1) + 
#         stat_summary(fun.y = mean, 
#                      aes_string(group = this_groups), 
#                      geom=c("point"), 
#                      position = position_dodge(.5)) + 
#         stat_summary(fun.y = mean, 
#                      aes_string(group = this_groups), 
#                      geom=c("line"), 
#                      size = 2, 
#                      position = position_dodge(.5)) + 
#         # stat_smooth(method = "loess", 
#         #             aes_string(group = this_groups), 
#         #             size = .01, 
#         #             span = 1, 
#         #             alpha = 0.1) + 
#         stat_sum_df(function(x) mean_cl_normal(x, conf.int = 0.68), 
#                     mapping = aes_string(group = this_groups), 
#                     position = position_dodge(.5)) + 
#         scale_color_aaas() + scale_fill_aaas() +
#         xlab("Time (days after surgery)") +
#         ylab(this_var) + 
#         scale_x_continuous(breaks = unique(this_df$Time)) +
#         ggtitle(paste(this_var)) +
#         theme_classic()
# }, mc.cores = detectCores()-1)
# names(plots.ts) <- paste(unique_results$biomarker, unique_results$group, sep = " | ")



# print out results
for(ii in 1:length(plots.ts)){
    cat("  \n###", names(plots.ts)[ii], "\n")
    
    suppressWarnings(print(plots.ts[[ii]]))
    
    cat("  \n")
    
    testid <- unique(models.fdr$testid[models.fdr$variable == unique_results$biomarker[ii] & 
                                           models.fdr$group == unique_results$group[ii]])
    this_anova <- anovatable.fdr[[testid]][,c("variable", "group", "parameter", "Chisq", "Df", "Pr(>Chisq)", "qval", "lfdr")]
    this_anova$stars <- sapply(this_anova$`Pr(>Chisq)`, p2stars)
    print(this_anova %>%
    # mutate(
    #     pvalue = cell_spec(pvalue, color = ifelse(resulttable.sort$pvalue > pcutoff, "grey", "green")),
    #     qvalue = cell_spec(qvalue, color = ifelse(resulttable.sort$qvalue > FDRcutoff, "grey", "green"))
    # ) %>% 
    kable(escape = F, row.names = F, caption = "Table 4a: Mixed effect model results") %>%
    kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                  font_size = 10) %>%
    scroll_box(width = "100%"))
   
    cat("  \n")
    


    
    print(posthoc.tests[[ii]] %>%          
    # mutate(
    #     pvalue = cell_spec(pvalue, color = ifelse(resulttable.sort$pvalue > pcutoff, "grey", "green")),
    #     qvalue = cell_spec(qvalue, color = ifelse(resulttable.sort$qvalue > FDRcutoff, "grey", "green"))
    # ) %>% 
    kable(escape = F, row.names = T, caption = "Table 4b: Post-hoc test results") %>%
    kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                  font_size = 10) %>%
    scroll_box(width = "100%"))
    cat("  \n")

    
    
    
}

```


# Identifying global patterns

## Hierarchical clustering

We double-standardized the data ([Efron 2009](https://projecteuclid.org/euclid.aoas/1254773272)) and computed the correlation matrix for the biomarkers using all pairwise complete data. We then clustered the biomarkers using those correlations, and clustered the samples that remained after removing missing data. We also clustered by time, after collapsing each biomarker to only its mean level.

```{r hclust, warning=FALSE, message=FALSE, cache = TRUE}

# color palette for this section
colorfun <- function(nlevels, func = pal_d3, ...){
    if(nlevels > 10) return(standardColors(nlevels))
    if(nlevels <=10) return(func(...)(nlevels))
} 

# annotations for our heatmap
annotation.row <- data.frame("biomarker" = factor(c(rep("B-cell", length(bc)),
                                                    rep("cytokine", length(cyt)))))
annotation.col <- df.raw[,which(make.names(colnames(df.raw), unique = T) %in% groups)]
annotation.colors <- lapply(colnames(annotation.col), function(nam){
    colrs <- colorfun(nlevels(annotation.col[[nam]]))
    names(colrs) <- levels(annotation.col[[nam]])
    return(colrs)
})
names(annotation.colors) <- colnames(annotation.col)
annotation.colors[["biomarker"]] <- colorfun(nlevels(annotation.row$biomarker))
names(annotation.colors[["biomarker"]]) <- levels(annotation.row$biomarker)

# double standardize
df.ds <- df.raw
df.ds[,bcellcyto] <- double_standardize(df.raw[, bcellcyto])
df.patient <- t(na.omit(df.ds[,bcellcyto]))
rownames(annotation.row) <- rownames(df.patient)

# compute silhouette for various biomarker clusters
r.biomarker <- cor(df.ds[, bcellcyto], use = "p")
nbclust <- fviz_nbclust(t(df.ds[, bcellcyto]), 
             hcut, 
             method = c("silhouette"),
             diss = as.dist((1-r.biomarker)/2), 
             k.max = 25) +
     labs(subtitle = "Silhouette method")

# compute optimal number of clusters
nclusters.bicluster <- as.numeric(as.character(nbclust$data$clusters[nbclust$data$y == max(nbclust$data$y)]))

# compute clusters
tree.bicluster <- hclust(as.dist((1-r.biomarker)/2), method = "ward.D2")
bicluster <- list()
bicluster$biomarkers_optimal <- cutree(tree.bicluster, k = nclusters.bicluster)
bicluster$biomarkers <- cutree(tree.bicluster, k = 4) # use 4 to simplify

# update annotations to include clusters
annotation.row$bicluster_optimal <- factor(bicluster$biomarkers_optimal)
annotation.row$bicluster <- factor(bicluster$biomarkers)
annotation.colors$bicluster <- colorfun(nlevels(annotation.row$bicluster), 
                                      func = pal_simpsons)
annotation.colors$bicluster_optimal <- colorfun(nlevels(annotation.row$bicluster_optimal), 
                                              func = pal_simpsons)
names(annotation.colors$bicluster) <- levels(factor(annotation.row$bicluster))
names(annotation.colors$bicluster_optimal) <- levels(factor(annotation.row$bicluster_optimal))

# # # make heatmap
# pheatmap(df.patient,
#          color = colorRampPalette(rev(brewer.pal(n = 10, name = "RdBu")))(100),
#          breaks = c(seq(-max(abs(df.patient), na.rm=T), 0, length.out = 50),
#                     seq(0.001, max(abs(df.patient), na.rm=T), length.out = 50)),
#          fontsize = 7,
#          cutree_rows = nclusters.bicluster,
#          cutree_cols = 2,
#          cluster_cols = T,
#          cluster_rows = tree.bicluster,
#          show_colnames = F,
#          annotation_col = annotation.col,
#          annotation_row = annotation.row,
#          annotation_colors = annotation.colors,
#          clustering_method = "ward.D2"
# )


# Temporal patterns

compute_module_means <- function(modules, df.ds, metadata.cols = 1:13, FUN = mean){
    nmods <- length(unique(modules))
    module.mean.list <- lapply(1:nmods, function(ii){
        this_names <- names(modules)[modules == ii]
        this_columns <- colnames(df.ds) %in% this_names
        this_mean <- apply(df.ds[,this_columns, drop = F], 1, FUN)
    })
    module.mean.matrix <- do.call(cbind, module.mean.list)
    module.mean.df <- as.data.frame(module.mean.matrix)
    colnames(module.mean.df) <- paste0("module.", unique(modules))
    return(cbind(df.ds[, metadata.cols], module.mean.df))
}

df.modules <- list()
df.modules$bicluster <- compute_module_means(bicluster$biomarkers, df.ds)
df.modules$bicluster_optimal <- compute_module_means(bicluster$biomarkers_optimal, df.ds)

# melt data into longform
df.modules.long <- lapply(df.modules, function(this_df.modules){
    melt(this_df.modules, id.vars = colnames(this_df.modules)[1:13])
})

# this_df <- df.modules.long$bicluster_optimal
# g3 <- ggplot(this_df) +
#         aes(x = as.numeric(as.character(Time)),
#             y = value,
#             color = factor(variable),
#             fill = factor(variable),
#             group = PatientID) +
#         geom_point(alpha = 0.1, size = 1) +
#         geom_line(alpha = 0.2) +
#         xlab("Time (days)") +
#         ylab("Standardized level") +
#         scale_x_continuous(breaks = unique(this_df$Time)) +
#         stat_summary(fun.y = mean,
#                      aes(group = variable),
#                      geom=c("line"),
#                      size = .02,
#                      position = position_dodge(.5)) +
#         stat_smooth(method = "loess",
#                     aes(group = variable),
#                     span = .5,
#                     size = 1,
#                     alpha = 0.1) +
#         stat_summary(fun.y = mean,
#                      aes(group = variable),
#                      geom=c("point"),
#                      position = position_dodge(.5)) +
#         stat_sum_df(function(x) mean_cl_normal(x, conf.int = 0.68),
#                     mapping = aes(group = variable),
#                     position = position_dodge(.5)) +
#         #scale_color_simpsons(name = "Cluster") +
#         #scale_fill_simpsons(name = "Cluster") +
#         theme_classic()
# #print(g3)



# Temporal clusters

df.ds.patients.0 <- split(df.ds, df.ds$PatientID)
df.ds.patients <- lapply(df.ds.patients.0, function(this_patient){
    this_patient[match(c(0,1,3,5,8,14,21), this_patient$Time),bcellcyto]
})

varnames <- colnames(df.ds[,bcellcyto])
meanlist <- lapply(varnames, function(this_var){
    temp <- aggregate(df.ds[[this_var]], 
              list(df.ds$Time), 
              FUN = function(x) mean(x, na.rm = T))
    colnames(temp) <- c("Time", "z")
    temp$biomarker <- this_var
    temp
})
names(meanlist) <- varnames

means.long <- do.call(rbind, meanlist)
means.wide.0 <- dcast(means.long, Time ~ biomarker, value.var = "z" )
means.wide <- means.wide.0[,c("Time", colnames(df)[bcellcyto])]

colorfun.time <- function(nlevels, ...){
    if(nlevels > 10) return(standardColors(nlevels))
    if(nlevels <=10) return(pal_d3(...)(nlevels))
} 
annotation.row.time <- data.frame("biomarker" = factor(c(rep("B-cell",29), rep("cytokine",38))))

annotation.colors.time <- lapply(colnames(annotation.row.time), function(nam){
    colrs <- colorfun.time(nlevels(annotation.row.time[[nam]]))
    names(colrs) <- levels(annotation.row.time[[nam]])
    return(colrs)
})
names(annotation.colors.time) <- colnames(annotation.row.time)

df.means <- as.data.frame(t(means.wide[,-1]))
rownames(annotation.row.time) <- rownames(df.means)

# compute optimal number of clusters
nbclust.time <- fviz_nbclust(df.means, 
                        hcut, 
                        method = c("silhouette"), 
                        diss = as.dist((1-cor(t(df.means), use = "p"))/2), 
                        k.max = 25)+
  labs(subtitle = "Silhouette method")

nclusters.timecluster <- as.numeric(as.character(nbclust.time$data$clusters[nbclust.time$data$y == max(nbclust.time$data$y)]))
```

## Optimal number of clusters

To determine the optimal number of clusters, we maximized the average silhouete width using the `factoextra` and `NbClust` packages.

```{r nbclust, cache = TRUE, fig.cap = "Figure 4: Optimal number of clusters"}
a <- nbclust + ggtitle("Optimal number of biomarker clusters")
b <- nbclust.time + ggtitle("Optimal number of timeclusters")
grid.arrange(a,b,ncol = 1)

```



```{r annotations, cache = TRUE}
# Temporal patterns

# do optimal clustering
tree.timecluster <- hclust(as.dist((1-cor(t(df.means), use = "p"))/2), 
               method = "ward.D2")
timeclusters <- cutree(tree.timecluster, k = nclusters.timecluster) # optimal number of clusters

# update annotations
annotation.row.time$time_cluster <- timeclusters
annotation.colors.time$time_cluster <- colorfun(nlevels(factor(annotation.row.time$time_cluster)))
names(annotation.colors.time$time_cluster) <- factor(unique(annotation.row.time$time_cluster))

# # add in clusters from the first clustering
# annotation.row.time$bicluster_optimal <- annotation.row$bicluster_optimal
# annotation.colors.time$bicluster_optimal <- annotation.colors$bicluster_optimal
# annotation.row.time$bicluster <- annotation.row$bicluster
# annotation.colors.time$bicluster <- annotation.colors$bicluster

hits <- as.character(unique(resulttable$biomarker))
annotation.row.hits <- data.frame(significant = rep(0, nrow(annotation.row)), 
                                  row.names = rownames(annotation.row))
annotation.row.hits$significant[rownames(annotation.row) %in% hits] <- 1

```

## Biclustering patterns

```{r heatmap_biclust, fig.height=10, cache = TRUE, fig.cap="Figure 5: Biclustering"}
# make biclustering heatmap
pheatmap(df.patient, 
         color = colorRampPalette(rev(brewer.pal(n = 10, name = "RdBu")))(100),
         breaks = c(seq(-max(abs(df.patient), na.rm=T), 0, length.out = 50), 
                    seq(0.001, max(abs(df.patient), na.rm=T), length.out = 50)),
         fontsize = 7,
         cutree_rows = nclusters.bicluster,
         cutree_cols = 2,
         cluster_cols = T,
         cluster_rows = tree.bicluster,
         show_colnames = F,
         annotation_col = annotation.col,
         #annotation_row = annotation.row.time,
         # annotation_row = cbind(annotation.row, 
         #                        time_cluster = annotation.row.time$time_cluster),
         annotation_row = cbind(annotation.row.time[,1,drop=F],
                                annotation.row.time[,2,drop=F],
                                annotation.row[,c(3,2),drop=F],
                                annotation.row.hits[,1,drop=F]),
         #annotation_colors = c(annotation.colors, annotation.colors.time),
         annotation_colors = c(annotation.colors, annotation.colors.time),
         clustering_method = "ward.D2",
         main = "Clusters"
)
```

## Time clustering patterns

```{r heatmap_timeclust, fig.height=9, cache = TRUE, fig.cap="Figure 6: Temporal clustering"}
pheatmap(df.means, 
         color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(100),
         breaks = c(seq(-max(abs(df.means), na.rm=T), 0, length.out = 50), 
                    seq(0.001, max(abs(df.means), na.rm=T), length.out = 50)),
         fontsize = 7,
         cutree_rows = 4,
         cutree_cols = 1,
         cluster_cols = F,
         cluster_rows = tree.timecluster,
         #annotation_col = annotation.col,
         # annotation_row = cbind(annotation.row, 
         #                        time_cluster = factor(annotation.row.time$time_cluster)),
         annotation_row = cbind(annotation.row.time[,1,drop=F], 
                                annotation.row.time[,2,drop=F],
                                annotation.row[,c(3,2),drop=F],
                                annotation.row.hits[,1,drop=F]),
         annotation_colors = c(annotation.colors, annotation.colors.time),
         clustering_method = "ward.D2",
         labels_col = means.wide$Time,
         border_color = NA,
         main = "Timeclusters"
)

```


### Timeseries

We depicted each biomarker cluster's temporal pattern as a smooth function of time, using a LOESS regression model. There are clear temporal dynamics occurring at multiple timescales.

```{r timeseries, warning=F, message=F, cache = TRUE, fig.cap="Figure 7: Time cluster profile"}
colnames(df.means) <- unique(means.long$Time)
df.means$timecluster <- factor(timeclusters)
df.means$biomarker <- rownames(df.means)

df.clustermeans <- melt(df.means, id.vars = c("biomarker", "timecluster"), variable.name = "Time", value.name = "z")

gg.time <- ggplot(df.clustermeans) + 
    aes(x=as.numeric(as.character(Time)), y=z, 
        color = timecluster, 
        group = biomarker, 
        fill = timecluster) + 
    geom_point(alpha = 0.1, size = 1) + 
    geom_line(alpha = 0.2) +
    xlab("Time (days)") +
    ylab("Standardized level (z-score)") +
    ggtitle("Temporal biomarker clusters") +
    scale_x_continuous(breaks = as.numeric(as.character(unique(df.clustermeans$Time)))) +
    stat_summary(fun.y = mean, 
                 aes(group = timecluster), 
                 geom=c("line"), 
                 size = .02, 
                 position = position_dodge(.5)) +
    stat_smooth(method = "loess", 
                aes(group = timecluster), 
                span = .6, 
                size = 1, 
                alpha = 0.2) +
    stat_summary(fun.y = mean, 
                 aes(group = timecluster), 
                 geom=c("point"), 
                 position = position_dodge(.5)) +
    # stat_sum_df(function(x) mean_cl_boot(x, conf.int = 0.68), 
    #             mapping = aes(group = timecluster), 
    #             position = position_dodge(.5)) + 
    scale_color_d3() + 
    scale_fill_d3() + 
    theme_classic()

print(gg.time)
```


## Cluster statistics {.tabset .tabset-pills}

### Biomarker clusters and timeclusters

We tested for overlap between the biomarker clusters and the timeclusters using Fisher's exact test.

```{r, results = 'asis'}
this_table <- table(cbind(annotation.row.time[,2,drop=F],
                          annotation.row[, 3, drop=F]))
print(this_table %>% kable(escape = F, row.names = T, caption = "Table 5: Contingency table") %>%
    kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                  font_size = 10) %>%
    scroll_box(width = "100%"))

cat("  \n")

```

Fisher's exact test $p=$ `r signif(fisher.test(this_table)$p.value, 3)` 

### Biomarker clusters and hits

We tested for overlap between the statistically significant biomarkers and the optimal biomarker clusters using Fisher's exact test.

```{r, results = 'asis'}
this_table <- table(cbind(annotation.row.hits[,1, drop=F],
                          annotation.row[,2, drop=F]))
print(this_table %>% kable(escape = F, row.names = T, caption = "Table 5: Contingency table") %>%
    kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                  font_size = 10) %>%
    scroll_box(width = "100%"))

cat("  \n")

```

Fisher's exact test $p=$ `r signif(fisher.test(this_table)$p.value, 3)` 

### Timeclusters and hits

We tested for overlap between the statistically significant biomarkers and the timeclusters using Fisher's exact test.

```{r, results = 'asis'}
this_table <- table(cbind(annotation.row.hits[,1, drop=F],
                          annotation.row.time[,2, drop=F]))
print(this_table %>% kable(escape = F, row.names = T, caption = "Table 5: Contingency table") %>%
    kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                  font_size = 10) %>%
    scroll_box(width = "100%"))

cat("  \n")

```

Fisher's exact test $p=$ `r signif(fisher.test(this_table)$p.value, 3)` 


### Biomarker type and hits

We tested for overlap between statistically significant biomarkers and their biomarker type.

```{r, results = 'asis'}
this_table <- table(cbind(annotation.row[,1, drop=F],
                          annotation.row.hits[,1, drop=F]))
print(this_table %>% kable(escape = F, row.names = T, caption = "Table 5: Contingency table") %>%
    kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                  font_size = 10) %>%
    scroll_box(width = "100%"))

cat("  \n")

```

Fisher's exact test $p=$ `r signif(fisher.test(this_table)$p.value, 3)` 

### Biomarker clusters and types

We tested for overlap between optimal biomarker clusters and biomarker type.

```{r, results = 'asis'}
this_table <- table(cbind(annotation.row[,1, drop=F],
                          annotation.row[,2, drop=F]))
print(this_table %>% kable(escape = F, row.names = T, caption = "Table 5: Contingency table") %>%
    kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                  font_size = 10) %>%
    scroll_box(width = "100%"))

cat("  \n")

```

Fisher's exact test $p=$ `r signif(fisher.test(this_table)$p.value, 3)` 

### Biomarker metaclusters and types

We tested for overlap between biomarker metaclusters and biomarker type.

```{r, results='asis'}
this_table <- table(cbind(annotation.row[,1, drop=F],
                          annotation.row[,3, drop=F]))
print(this_table %>% kable(escape = F, row.names = T, caption = "Table 5: Contingency table") %>%
    kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                  font_size = 10) %>%
    scroll_box(width = "100%"))

cat("  \n")

```

Fisher's exact test $p=$ `r signif(fisher.test(this_table)$p.value, 3)` 

### Timeclusters and types

We tested for overlap between timeclusters and biomarker type.


```{r, results = 'asis'}
this_table <- table(cbind(annotation.row[,1, drop=F],
                          annotation.row.time[,2, drop=F]))
print(this_table %>% kable(escape = F, row.names = T, caption = "Table 5: Contingency table") %>%
    kable_styling(bootstrap_options = c("striped", 
                                        "hover", 
                                        "condensed",
                                        "responsive"),
                  font_size = 10) %>%
    scroll_box(width = "100%"))

cat("  \n")

```

Fisher's exact test $p=$ `r signif(fisher.test(this_table)$p.value, 3)` 



